http://www.cplusplus.com/doc/tutorial/
http://www.cplusplus.com/reference/iostream/
The compiler to use is clang++.
------------------------------------------------------------------------------------------------------------
D00 - C++ Basics

INTRODUCTION
NAMESPACES
  Open main.cpp file.
  
  #include <stdio.h>
  int gl_var = 1;
  int f( void ) {return 2;}
  
  namespace Foo {
    int gl_var = 3;
    int f( void ) {return 4;}
  }
  
  namespace Bar {
    int gl_var = 5;
    int f( void ) {return 6;}
  }
  
  namespace Muf = Bar;
  
  int main(void) {
    printf("gl_var:   [%d]\n", gl_var);
    printf("f():      [%d]\n\n", f());
    
    // :: is scope resolution operator
    printf("Foo::gl_var:   [%d]\n", Foo::gl_var);
    printf("Foo::f():      [%d]\n\n", Foo::f());
    
    printf("Bar::gl_var:   [%d]\n", Bar::gl_var);
    printf("Bar::f():      [%d]\n\n", Bar::f());
    
    printf("Muf::gl_var:   [%d]\n", Muf::gl_var);
    printf("Muf::f():      [%d]\n\n", Muf::f());
    
    printf("::gl_var:   [%d]\n", ::gl_var); // the output of '::gl_var' will be the same as 'gl_var'.
    printf("::f():      [%d]\n\n", ::f());  
    
    return 0;
  }
  
  To compile: g++ -Wall -Wextra -Wno-used -Werror main.cpp
  To run: ./a.out
  
STDIO STREAMS
  Let's see how c++ handles inputs & outputs
  
  Open main.cpp (to test)
  
  #include <iostream>
  int main(void) {
    char buff[512];
    std::cout << "Hello world !" << std::endl;
    std::cout << "Input a word: ";
    std::cin >> buff;
    std::cout << "You entered: [" << buff << "]" << std::endl;
    return 0;
  }

CLASS AND INSTANCE
  Open Sample.class.h (to declare the class and f-ns and attributes)
  
  #ifndef SAMPLE_CLASS_H
  # define SAMPLE_CLASS_H
  class Sample {
  public: 
    Sample(void);       // declaration of constructor
    ~Sample(void);      // declaration of destructor
  };
  #endif
  
  Open Sample.class.cpp (to define these f-ns present in class)
  
  #include <iostream>
  #include "Sample.class.hpp"
  Sample::Sample(void){
    std::cout << "Constructor called" << std::endl;
    return;
  }
  Sample::~Sample(void){
    std::cout << "Destructor called" << std::endl;
    return;
  }
  
  Open main.cpp. 
  Let's see how to create instance. 
  
  #include "Sample.class.hpp"
  int main() {
    Sample instance;
    return 0;
  }

MEMBER ATTRIBUTES AND MEMBER FUNCTIONS
    Now that we know how to declare class and implement its constructor and its destructor, 
    we'll discover how to put things in our class to make it more useful. We'll discover the notion of member attribute and member f-n.
    A member attribute is just variable you have in your class and you may use from an instance.
    A member f-n is a f-n in my class that I'll be able to use from the instance of my class.
    In C, if we want to add a f-n to our structure - it would be impossible in C, the only way to do it is to have a pointer 
    on a f-n in our structure.
    In C++, we have a possibility to declare directly a f-n in our class. The implementation of this f-n as well as its definition
    work the same way as a constructor and a desctructor but this time we'll have a return type in front.
    
    Open Sample.class.h 
  
    #ifndef SAMPLE_CLASS_H
    # define SAMPLE_CLASS_H
    class Sample {
    public: 
      int foo;        // (member attribute) declaration of integer variable named foo
      Sample(void);
      ~Sample(void);
      void bar(void); // member f-n (will be usuful when the class will be instanciated)
    };
    #endif

    Open Sample.class.cpp 

    #include <iostream>
    #include "Sample.class.hpp"
    Sample::Sample(void){
      std::cout << "Constructor called" << std::endl;
      return;
    }
    Sample::~Sample(void){
      std::cout << "Destructor called" << std::endl;
      return;
    }
    //
    void Sample::bar(void) {
      std::cout << "Member f-n bar called" << std::endl;
      return;
    }
    
    Open main.cpp
  
    #include "Sample.class.hpp"
    int main() {
      Sample instance;
      instance.foo = 42;
      std::cout << "instance.foo: " << instance.foo << std:endl;
      instance.bar();   // to call member f-n
      return 0;
    }
    //so instance is stack variable
    
    
THIS
  this is a pointer to current instance
  
  Open Sample.class.cpp 

    #include <iostream>
    #include "Sample.class.hpp"
    Sample::Sample(void){
      std::cout << "Constructor called" << std::endl;
      this->foo = 42;
      std::cout << "this->foo: " << this->foo << std::endl;
      this->bar();
      return;
    }
    Sample::~Sample(void){
      std::cout << "Destructor called" << std::endl;
      return;
    }
    //
    void Sample::bar(void) {
      std::cout << "Member f-n bar called" << std::endl;
      return;
    }
    
    // To compile: g++ -Wall -Wextra -Wno-used -Werror Sample.class.cpp main.cpp
  
  
INITIALIZATION LIST
    Open Sample1.class.h 
  
    #ifndef SAMPLE1_CLASS_H
    # define SAMPLE1_CLASS_H
    class Sample1 {
    public: 
      // attributes
      char a1;
      int a2;
      float a3;
      
      Sample1(char p1, int p2, float p3);  // constructor's parameters
      ~Sample1(void);
      
    };
    #endif  
    
    Open Sample2.class.cpp 

    #include <iostream>
    #include "Sample2.class.hpp"
    // here I use a syntax called initialization list
    Sample2::Sample2(char p1, int p2, float p3) : a1(p1), a2(p2), a3(p3){
      std::cout << "Constructor called" << std::endl;
      std::cout << "this->a1: " << this->a1 << std::endl;
      std::cout << "this->a2: " << this->a2 << std::endl;
      std::cout << "this->a3: " << this->a3 << std::endl;
      return;
    }
    Sample2::~Sample2(void){
      std::cout << "Destructor called" << std::endl;
      return;
    }
    
    // use syntax from above - not from below
    Sample1::Sample1(char p1, int p2, float p3) {
      std::cout << "Constructor called" << std::endl;
      this->a1 = p1;
      std::cout << "this->a1: " << this->a1 << std::endl;
      this->a2 = p2;
      std::cout << "this->a2: " << this->a2 << std::endl;
      this->a3 = p3;
      std::cout << "this->a3: " << this->a3 << std::endl;
      return;
    }
    
    Open main.cpp
    #include <iostream>
    #include "Sample1.class.hpp"
    #include "Sample2.class.hpp"
    int main() {
      Sample1 instance1 ('a', 42, 4.2f);
      Sample2 instance2 ('z', 13, 3.14f);
      return 0;
    }
    
    // To compile: g++ -Wall -Wextra -Wno-used -Werror Sample1.class.cpp Sample2.class.cpp main.cpp
    
CONST
  We can't assign value to const, we can only initialize const to the value
  
  Open Sample1.class.h 
  
    #ifndef SAMPLE_CLASS_H
    # define SAMPLE_CLASS_H
    class Sample {
    public: 
      float const pi;
      int         qd;
      
      Sample(float const f);  
      ~Sample(void);
      void bar(void) const;
    };
    #endif  
    
    Open Sample.class.cpp 

    #include <iostream>
    #include "Sample.class.hpp"
    Sample::Sample(float const f) : pi(f), qd(42){
      std::cout << "Constructor called" << std::endl;
      return;
    }
    Sample::~Sample(void){
      std::cout << "Destructor called" << std::endl;
      return;
    }
    void Sample::bar(void) const {
      std::cout << "this->pi: " << this->pi << std::endl; 
      std::cout << "this->qd: " << this->qd << std::endl;
      //this->qd = 0; // read-only error
      return;
    }
    
    
VISIBILITY
  public and private keywords wil allow me to control encapsulation of the members of our class.
  That means Members attributes and f-ns will be visible from inside of class or from outside.
  Use undescore for private.
  If you try to access private attribute or f-n - it won't compile.
  
CLASS VS STRUCT
  Structures(but without specifying public/private which won't lead to error in compiling) have the same syntax as classes. 
  Structures and classes works in the same way in C++. It's all about outputs.
  So, The difference is that the scope in structures is public by default. 
  
    #ifndef SAMPLE1_CLASS_H
    # define SAMPLE1_CLASS_H
    struct Sample1 {
    public: 
      int  foo;
      
      Sample1(void);  
      ~Sample1(void);
      void bar(void) const;
    };
    #endif 
  
ACCESSORS
    get, getFoo [get followed by a name of getter]
    set
    
    Open Sample.class.cpp
    ..
    public: 
      Sample1(void);  
      ~Sample1(void);
      int getFoo(void) const;
      void setFoo(int v);
    };
    private:
      int _foo;
    ..
    
    Open Sample.class.php
    ....
    int Sample::getFoo(void) const {
      return this->_foo;
    }
    int Sample::setFoo(int v) {
      if (v >= 0)
          this->_foo = v;
      return;
    }
    
COMPARISONS
  == 
  
  if (&instance1 == &instance1) 
      std::count << "instance1 and instance1 are physically equal" << std:endl;
  if (&instance1.compare(&instance1) == 0) 
      std::count << "instance1 and instance1 are structurally equal" << std:endl;
    
NON MEMBER ATTRIBUTES AND NON MEMBER FUNCTIONS
    Open Sample.class.cpp
    ..
    public: 
      Sample1(void);  
      ~Sample1(void);
      static int getNbInst(void);
    };
    private:
      static int _nbInst;
    ..
    
POINTERS TO MEMBERS

CONCLUSION

------------------------------------------------------------------------------------------------------------

D01 - C++ Basics 2

NEW AND DELETE
    Memory management 
    In C, you used malloc(); In C++, you also can but it's a bad idea.
    
    #include <string>
    class Student {
      private:
          std:: string _login;
      public:
          // Student() : _login("ldefault")
          Student(std:: string login) : _login(login);
          {
              std:: count << "Student " << this->_login << "is born" << std::endl;
          }
          ~Student();
          {
              std:: count << "Student " << this->_login << "is died" << std::endl;
          }
    };
    int main() {
        // Student* students = new Student[42];
        Student bob = Student("bfubar");
        Student* jim = new Student("jfubar");
        // Do some stuff here
        // deallocate, there used to be malloc free, now it's delete
        // delete [] students;
        delete jim;   //jim is destroyed
        return 0;     // bob is destroyed
    }
    
REFERENCES
    Now let's talk about new C++ concept - references.
    We'll do comparison to pointers in C.
    
FILESTREAM
  how to use input/outputs to make actions in files.
  ifstream - input file stream
  ofstream - output file stream
  
  Open fstream1.cpp
  
  #include <iostream>
  #include <fstream>
  int main() {
      std::ifstream   ifs("numbers");
      unsigned int    dst;
      unsigned int    dst2;
      ifs >> dst >> dst2;
      std::count << dst << " " << dst2 << std::endl;
      ifs.close();
      //------------
      std::ofstream   ifs("test.out");
      ofs << "i like ponies" << std::endl;
      ofs.close();
  }
  
  To compile: g++ fstream1.cpp
  ./a.out
  cat test.out
  rm test.out
  
------------------------------------------------------------------------------------------------------------

D02

INTRODUCTION
AD-HOC POLYMORPHISM
    Function overloading. 
    Principle: you have 1 f-n name and different parameters for overload - this will allow you to specialize the process of a f-n
    based on parameters.
    
    Open Sample.class.h
  
    #ifndef SAMPLE_CLASS_H
    # define SAMPLE_CLASS_H
    class Sample {
    public: 
      Sample(void);       
      ~Sample(void);      
      // below you see 4 bar overloads
      void bar(char const c) const;
      void bar(int const n) const;
      void bar(float const z) const;
      void bar(Sample const & i) const;
    };
    #endif
    
    Open Sample.class.cpp
    ..
    void Sample::bar(char const c) const {
      std:: count << "Member f-n bar called with char overload" << std::endl;   
      return;
    }
    void Sample::bar(int const n) const {
      std:: count << "Member f-n bar called with int overload" << std::endl;   
      return;
    }
    void Sample::bar(float const z) const {
      std:: count << "Member f-n bar called with float overload" << std::endl;   
      return;
    }
    void Sample::bar(Sample const & i) const {
      std:: count << "Member f-n bar called with Sample class overload" << std::endl;   
      return;
    }
    ..
    
    
OPERATOR OVERLOAD
    + 1 1 prefix (functional notation) 
    + (1, 1)
    1.+( 1 ) plus member f-n
    
    1 + 1 infix notation
    1 1 + postfix (stack calculation) (pulish reverse notation ??)
    ...
    
CANONICAL FORM
    coplin??
CONCLUSION

------------------------------------------------------------------------------------------------------------

D03 - Inheritance

INHERITANCE C++

------------------------------------------------------------------------------------------------------------

D04 - Sub-typing polymorphism

SUB-TYPING POLYMORPHISM
ABSTRACT CLASSES AND INTERFACES

------------------------------------------------------------------------------------------------------------

D05 - Nested classes and Exceptions

NESTED CLASSES
EXCEPTIONS

------------------------------------------------------------------------------------------------------------

D06 - Casts

INTRODUCTION
FROM C - TYPE CONVERSION
FROM C - TYPE REINTERPRETATION
FROM C - TYPE QUALIFIER REINTERPRETATION
UPCAST AND DOWNCAST
STATIC CAST
DYNAMIC CAST
REINTERPRET CAST
CONST CAST
CAST OPERATORS
EXPLICIT KEYWORD
CONCLUSION

------------------------------------------------------------------------------------------------------------

D07 - Templates

INTRODUCTION
TEMPLATES
DEFAULT TYPE
SPECIALIZATION
CONCLUSION
FROM C - PARAMETRIC MACROS

------------------------------------------------------------------------------------------------------------

D08 - STL

STL

------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------

MY NOTES

Для работы с памятью введены операторы new, new[], delete и delete[]. В отличие от библиотечных malloc и free, пришедших из C, данные операторы производят инициализацию объекта. Для классов это вызов конструктора, для POD типов инициализацию можно либо не проводить(new Pod;), либо провести инициализацию нулевыми значениями (new Pod(); new Pod{};).


Типы
- Символьные: char, wchar_t (char16_t и char32_t, в стандарте C++11).
- Целочисленные знаковые: signed char, short int, int, long int (и long long, в стандарте C++11).
- Целочисленные беззнаковые: unsigned char, unsigned short int, unsigned int, unsigned long int(и unsigned long long, в стандарте C++11).
- С плавающей точкой: float, double, long double.
- Логический: bool, имеющий значения true или false.

В стандарте C++ под классом (class) подразумевается пользовательский тип, объявленный с использованием одного из ключевых слов class, struct или union, под структурой (structure) подразумевается класс, определённый через ключевое слово struct, и под объединением (union) подразумевается класс, определённый через ключевое слово union.

В теле определения класса можно указать как объявления функций, так и их определение. В последнем случае функция является встраиваемой (inline)). Нестатические функции-члены могут иметь квалификаторы const и volatile, а также ссылочный квалификатор (& или &&).

Друзья
Функции-друзья — это функции, не являющиеся функциями-членами и тем не менее имеющие доступ к защищённым и закрытым членам класса. Они должны быть объявлены в теле класса как friend. Например:

class Matrix {
    friend Matrix Multiply(Matrix m1, Matrix m2);
};
Здесь функция Multiply может обращаться к любым полям и функциям-членам класса Matrix.

Класс по умолчанию может иметь шесть специальных функций: конструктор по умолчанию, конструктор копирования, конструктор перемещения, деструктор, оператор присваивания копированием, оператор присваивания перемещением. 

C++ не разрешает вызывать функцию main() внутри программы, в то время как в C это действие правомерно. 
Более того, код, верный для обоих языков, может давать разные результаты в зависимости от того, компилятором какого языка он оттранслирован. Так происходит из-за того, что символьные константы в C (например, 'a') имеют тип int, а в C++ — тип char, а размеры этих типов обычно различаются.

Средства C, которых рекомендуется избегать
1) Не использовать макроопределения #define. Для объявления констант применять const, групп констант (перечислений) — enum, для прямого включения функций — inline, для определения семейств функций или типов — template.
2) Не использовать предварительные объявления переменных. Объявлять переменные в блоке, где они реально используются, всегда совмещая объявление с инициализацией.
3) Отказаться от использования malloc() в пользу оператора new, от realloc() — в пользу типа vector. Более безопасным будет использование умных указателей, таких как shared_ptr и unique_ptr, доступных с одиннадцатой версии стандарта.
4) Избегать бестиповых указателей, арифметики указателей, неявных приведений типов, объединений, за исключением, возможно, низкоуровневого кода. Использовать «новые» преобразования типов, как более точно выражающие действительные намерения программиста и более безопасные.
5) Свести к минимуму использование массивов символов и строк в стиле C, заменив их на типы string и vector из STL. Вообще не стремиться создавать собственные реализации того, что уже имеется в стандартной библиотеке.

STL (Standard Template Library) - стандартная библиотека шаблонов.

#include <iostream> // для использования std::cout

В C++ (как и в C), если выполнение программы доходит до конца функции main(), то это эквивалентно return 0;. Это неверно для любой другой функции кроме main().

----------------
Операционные системы как Linux и macOS имеют уже встроенный компилятор C++, который называется g++.
// создадутся file1.o, file2.o и file3.o. -c означает «только скомпилировать», т.е. просто создать .o (объектные) файлы. 
g++ -c file1.cpp file2.cpp file3.cpp   
// -o сообщает g++, что мы хотим получить исполняемый файл с именем prog из файлов: file1.o, file2.o и file3.o.
g++ -o prog file1.o file2.o file3.o
// компиляцию и линкинг можно объединить в один шаг:
g++ -o prog file1.cpp file2.cpp file3.cpp
Исходный файл(.cpp) --> Обьектный файл (.о) --> Исполняемый файл

Консольные приложения (запускаются с командной строки) не имеют графического интерфейса пользователя (GUI) и компилируются в автономные исполняемые файлы.

Конфигурация сборки (build configuration):Release (релиз) и Debug (отладка).

Statement (стейтмент)
1) int х;               это statement declaration (операция объявления).
2) х = 5;               это assignment statement (операция присваивания).
3) std::cout << x;      это output statement (операция вывода).


