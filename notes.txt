http://www.cplusplus.com/doc/tutorial/
http://www.cplusplus.com/reference/iostream/
The compiler to use is clang++.
------------------------------------------------------------------------------------------------------------
D00 - C++ Basics

INTRODUCTION
NAMESPACES
  Open main.cpp file.
  
  #include <stdio.h>
  int gl_var = 1;
  int f( void ) {return 2;}
  
  namespace Foo {
    int gl_var = 3;
    int f( void ) {return 4;}
  }
  
  namespace Bar {
    int gl_var = 5;
    int f( void ) {return 6;}
  }
  
  namespace Muf = Bar;
  
  int main(void) {
    printf("gl_var:   [%d]\n", gl_var);
    printf("f():      [%d]\n\n", f());
    
    // :: is scope resolution operator
    printf("Foo::gl_var:   [%d]\n", Foo::gl_var);
    printf("Foo::f():      [%d]\n\n", Foo::f());
    
    printf("Bar::gl_var:   [%d]\n", Bar::gl_var);
    printf("Bar::f():      [%d]\n\n", Bar::f());
    
    printf("Muf::gl_var:   [%d]\n", Muf::gl_var);
    printf("Muf::f():      [%d]\n\n", Muf::f());
    
    printf("::gl_var:   [%d]\n", ::gl_var); // the output of '::gl_var' will be the same as 'gl_var'.
    printf("::f():      [%d]\n\n", ::f());  
    
    return 0;
  }
  
  To compile: g++ -Wall -Wextra -Wno-used -Werror main.cpp
  To run: ./a.out
  
STDIO STREAMS
  Let's see how c++ handles inputs & outputs
  
  Open main.cpp (to test)
  
  #include <iostream>
  int main(void) {
    char buff[512];
    std::cout << "Hello world !" << std::endl;
    std::cout << "Input a word: ";
    std::cin >> buff;
    std::cout << "You entered: [" << buff << "]" << std::endl;
    return 0;
  }

CLASS AND INSTANCE
  Open Sample.class.h (to declare the class and f-ns and attributes)
  
  #ifndef SAMPLE_CLASS_H
  # define SAMPLE_CLASS_H
  class Sample {
  public: 
    Sample(void);       // declaration of constructor
    ~Sample(void);      // declaration of destructor
  };
  #endif
  
  Open Sample.class.cpp (to define these f-ns present in class)
  
  #include <iostream>
  #include "Sample.class.hpp"
  Sample::Sample(void){
    std::cout << "Constructor called" << std::endl;
    return;
  }
  Sample::~Sample(void){
    std::cout << "Destructor called" << std::endl;
    return;
  }
  
  Open main.cpp. 
  Let's see how to create instance. 
  
  #include "Sample.class.hpp"
  int main() {
    Sample instance;
    return 0;
  }

MEMBER ATTRIBUTES AND MEMBER FUNCTIONS
    Now that we know how to declare class and implement its constructor and its destructor, 
    we'll discover how to put things in our class to make it more useful. We'll discover the notion of member attribute and member f-n.
    A member attribute is just variable you have in your class and you may use from an instance.
    A member f-n is a f-n in my class that I'll be able to use from the instance of my class.
    In C, if we want to add a f-n to our structure - it would be impossible in C, the only way to do it is to have a pointer 
    on a f-n in our structure.
    In C++, we have a possibility to declare directly a f-n in our class. The implementation of this f-n as well as its definition
    work the same way as a constructor and a desctructor but this time we'll have a return type in front.
    
    Open Sample.class.h 
  
    #ifndef SAMPLE_CLASS_H
    # define SAMPLE_CLASS_H
    class Sample {
    public: 
      int foo;        // (member attribute) declaration of integer variable named foo
      Sample(void);
      ~Sample(void);
      void bar(void); // member f-n (will be usuful when the class will be instanciated)
    };
    #endif

    Open Sample.class.cpp 

    #include <iostream>
    #include "Sample.class.hpp"
    Sample::Sample(void){
      std::cout << "Constructor called" << std::endl;
      return;
    }
    Sample::~Sample(void){
      std::cout << "Destructor called" << std::endl;
      return;
    }
    //
    void Sample::bar(void) {
      std::cout << "Member f-n bar called" << std::endl;
      return;
    }
    
    Open main.cpp
  
    #include "Sample.class.hpp"
    int main() {
      Sample instance;
      instance.foo = 42;
      std::cout << "instance.foo: " << instance.foo << std:endl;
      instance.bar();   // to call member f-n
      return 0;
    }
    //so instance is stack variable
    
    
THIS
  this is a pointer to current instance
  
  Open Sample.class.cpp 

    #include <iostream>
    #include "Sample.class.hpp"
    Sample::Sample(void){
      std::cout << "Constructor called" << std::endl;
      this->foo = 42;
      std::cout << "this->foo: " << this->foo << std::endl;
      this->bar();
      return;
    }
    Sample::~Sample(void){
      std::cout << "Destructor called" << std::endl;
      return;
    }
    //
    void Sample::bar(void) {
      std::cout << "Member f-n bar called" << std::endl;
      return;
    }
    
    // To compile: g++ -Wall -Wextra -Wno-used -Werror Sample.class.cpp main.cpp
  
  
INITIALIZATION LIST
    Open Sample1.class.h 
  
    #ifndef SAMPLE1_CLASS_H
    # define SAMPLE1_CLASS_H
    class Sample1 {
    public: 
      // attributes
      char a1;
      int a2;
      float a3;
      
      Sample1(char p1, int p2, float p3);  // constructor's parameters
      ~Sample1(void);
      
    };
    #endif  
    
    Open Sample2.class.cpp 

    #include <iostream>
    #include "Sample2.class.hpp"
    // here I use a syntax called initialization list
    Sample2::Sample2(char p1, int p2, float p3) : a1(p1), a2(p2), a3(p3){
      std::cout << "Constructor called" << std::endl;
      std::cout << "this->a1: " << this->a1 << std::endl;
      std::cout << "this->a2: " << this->a2 << std::endl;
      std::cout << "this->a3: " << this->a3 << std::endl;
      return;
    }
    Sample2::~Sample2(void){
      std::cout << "Destructor called" << std::endl;
      return;
    }
    
    // use syntax from above - not from below
    Sample1::Sample1(char p1, int p2, float p3) {
      std::cout << "Constructor called" << std::endl;
      this->a1 = p1;
      std::cout << "this->a1: " << this->a1 << std::endl;
      this->a2 = p2;
      std::cout << "this->a2: " << this->a2 << std::endl;
      this->a3 = p3;
      std::cout << "this->a3: " << this->a3 << std::endl;
      return;
    }
    
    Open main.cpp
    #include <iostream>
    #include "Sample1.class.hpp"
    #include "Sample2.class.hpp"
    int main() {
      Sample1 instance1 ('a', 42, 4.2f);
      Sample2 instance2 ('z', 13, 3.14f);
      return 0;
    }
    
    // To compile: g++ -Wall -Wextra -Wno-used -Werror Sample1.class.cpp Sample2.class.cpp main.cpp
    
CONST
  We can't assign value to const, we can only initialize const to the value
  
  Open Sample1.class.h 
  
    #ifndef SAMPLE_CLASS_H
    # define SAMPLE_CLASS_H
    class Sample {
    public: 
      float const pi;
      int         qd;
      
      Sample(float const f);  
      ~Sample(void);
      void bar(void) const;
    };
    #endif  
    
    Open Sample.class.cpp 

    #include <iostream>
    #include "Sample.class.hpp"
    Sample::Sample(float const f) : pi(f), qd(42){
      std::cout << "Constructor called" << std::endl;
      return;
    }
    Sample::~Sample(void){
      std::cout << "Destructor called" << std::endl;
      return;
    }
    void Sample::bar(void) const {
      std::cout << "this->pi: " << this->pi << std::endl; 
      std::cout << "this->qd: " << this->qd << std::endl;
      //this->qd = 0; // read-only error
      return;
    }
    
    
VISIBILITY
  public and private keywords wil allow me to control encapsulation of the members of our class.
  That means Members attributes and f-ns will be visible from inside of class or from outside.
  Use undescore for private.
  If you try to access private attribute or f-n - it won't compile.
  
CLASS VS STRUCT
  Structures(but without specifying public/private which won't lead to error in compiling) have the same syntax as classes. 
  Structures and classes works in the same way in C++. It's all about outputs.
  So, The difference is that the scope in structures is public by default. 
  
    #ifndef SAMPLE1_CLASS_H
    # define SAMPLE1_CLASS_H
    struct Sample1 {
    public: 
      int  foo;
      
      Sample1(void);  
      ~Sample1(void);
      void bar(void) const;
    };
    #endif 
  
ACCESSORS
    get, getFoo [get followed by a name of getter]
    set
    
    Open Sample.class.cpp
    ..
    public: 
      Sample1(void);  
      ~Sample1(void);
      int getFoo(void) const;
      void setFoo(int v);
    };
    private:
      int _foo;
    ..
    
    Open Sample.class.php
    ....
    int Sample::getFoo(void) const {
      return this->_foo;
    }
    int Sample::setFoo(int v) {
      if (v >= 0)
          this->_foo = v;
      return;
    }
    
COMPARISONS
  == 
  
  if (&instance1 == &instance1) 
      std::count << "instance1 and instance1 are physically equal" << std:endl;
  if (&instance1.compare(&instance1) == 0) 
      std::count << "instance1 and instance1 are structurally equal" << std:endl;
    
NON MEMBER ATTRIBUTES AND NON MEMBER FUNCTIONS
    Open Sample.class.cpp
    ..
    public: 
      Sample1(void);  
      ~Sample1(void);
      static int getNbInst(void);
    };
    private:
      static int _nbInst;
    ..
    
POINTERS TO MEMBERS

CONCLUSION

------------------------------------------------------------------------------------------------------------

D01 - C++ Basics 2

NEW AND DELETE
    Memory management 
    In C, you used malloc(); In C++, you also can but it's a bad idea.
    
    #include <string>
    class Student {
      private:
          std:: string _login;
      public:
          // Student() : _login("ldefault")
          Student(std:: string login) : _login(login);
          {
              std:: count << "Student " << this->_login << "is born" << std::endl;
          }
          ~Student();
          {
              std:: count << "Student " << this->_login << "is died" << std::endl;
          }
    };
    int main() {
        // Student* students = new Student[42];
        Student bob = Student("bfubar");
        Student* jim = new Student("jfubar");
        // Do some stuff here
        // deallocate, there used to be malloc free, now it's delete
        // delete [] students;
        delete jim;   //jim is destroyed
        return 0;     // bob is destroyed
    }
    
REFERENCES
    Now let's talk about new C++ concept - references.
    We'll do comparison to pointers in C.
    
FILESTREAM
  how to use input/outputs to make actions in files.
  ifstream - input file stream
  ofstream - output file stream
  
  Open fstream1.cpp
  
  #include <iostream>
  #include <fstream>
  int main() {
      std::ifstream   ifs("numbers");
      unsigned int    dst;
      unsigned int    dst2;
      ifs >> dst >> dst2;
      std::count << dst << " " << dst2 << std::endl;
      ifs.close();
      //------------
      std::ofstream   ifs("test.out");
      ofs << "i like ponies" << std::endl;
      ofs.close();
  }
  
  To compile: g++ fstream1.cpp
  ./a.out
  cat test.out
  rm test.out
  
------------------------------------------------------------------------------------------------------------

D02

INTRODUCTION
AD-HOC POLYMORPHISM
    Function overloading. 
    Principle: you have 1 f-n name and different parameters for overload - this will allow you to specialize the process of a f-n
    based on parameters.
    
    Open Sample.class.h
  
    #ifndef SAMPLE_CLASS_H
    # define SAMPLE_CLASS_H
    class Sample {
    public: 
      Sample(void);       
      ~Sample(void);      
      // below you see 4 bar overloads
      void bar(char const c) const;
      void bar(int const n) const;
      void bar(float const z) const;
      void bar(Sample const & i) const;
    };
    #endif
    
    Open Sample.class.cpp
    ..
    void Sample::bar(char const c) const {
      std:: count << "Member f-n bar called with char overload" << std::endl;   
      return;
    }
    void Sample::bar(int const n) const {
      std:: count << "Member f-n bar called with int overload" << std::endl;   
      return;
    }
    void Sample::bar(float const z) const {
      std:: count << "Member f-n bar called with float overload" << std::endl;   
      return;
    }
    void Sample::bar(Sample const & i) const {
      std:: count << "Member f-n bar called with Sample class overload" << std::endl;   
      return;
    }
    ..
    
    
OPERATOR OVERLOAD
    + 1 1 prefix (functional notation) 
    + (1, 1)
    1.+( 1 ) plus member f-n
    
    1 + 1 infix notation
    1 1 + postfix (stack calculation) (pulish reverse notation ??)
    ...
    
CANONICAL FORM
    coplin??
CONCLUSION

------------------------------------------------------------------------------------------------------------

D03 - Inheritance

INHERITANCE C++

------------------------------------------------------------------------------------------------------------

D04 - Sub-typing polymorphism

SUB-TYPING POLYMORPHISM
ABSTRACT CLASSES AND INTERFACES

------------------------------------------------------------------------------------------------------------

D05 - Nested classes and Exceptions

NESTED CLASSES
EXCEPTIONS

------------------------------------------------------------------------------------------------------------

D06 - Casts

INTRODUCTION
FROM C - TYPE CONVERSION
FROM C - TYPE REINTERPRETATION
FROM C - TYPE QUALIFIER REINTERPRETATION
UPCAST AND DOWNCAST
STATIC CAST
DYNAMIC CAST
REINTERPRET CAST
CONST CAST
CAST OPERATORS
EXPLICIT KEYWORD
CONCLUSION

------------------------------------------------------------------------------------------------------------

D07 - Templates

INTRODUCTION
TEMPLATES
DEFAULT TYPE
SPECIALIZATION
CONCLUSION
FROM C - PARAMETRIC MACROS

------------------------------------------------------------------------------------------------------------

D08 - STL

STL

------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------

MY NOTES

Для работы с памятью введены операторы new, new[], delete и delete[]. В отличие от библиотечных malloc и free, пришедших из C, данные операторы производят инициализацию объекта. Для классов это вызов конструктора, для POD типов инициализацию можно либо не проводить(new Pod;), либо провести инициализацию нулевыми значениями (new Pod(); new Pod{};).


Типы
- Символьные: char, wchar_t (char16_t и char32_t, в стандарте C++11).
- Целочисленные знаковые: signed char, short int, int, long int (и long long, в стандарте C++11).
- Целочисленные беззнаковые: unsigned char, unsigned short int, unsigned int, unsigned long int(и unsigned long long, в стандарте C++11).
- С плавающей точкой: float, double, long double.
- Логический: bool, имеющий значения true или false.

В стандарте C++ под классом (class) подразумевается пользовательский тип, объявленный с использованием одного из ключевых слов class, struct или union, под структурой (structure) подразумевается класс, определённый через ключевое слово struct, и под объединением (union) подразумевается класс, определённый через ключевое слово union.

В теле определения класса можно указать как объявления функций, так и их определение. В последнем случае функция является встраиваемой (inline)). Нестатические функции-члены могут иметь квалификаторы const и volatile, а также ссылочный квалификатор (& или &&).

Друзья
Функции-друзья — это функции, не являющиеся функциями-членами и тем не менее имеющие доступ к защищённым и закрытым членам класса. Они должны быть объявлены в теле класса как friend. Например:

class Matrix {
    friend Matrix Multiply(Matrix m1, Matrix m2);
};
Здесь функция Multiply может обращаться к любым полям и функциям-членам класса Matrix.

Класс по умолчанию может иметь шесть специальных функций: конструктор по умолчанию, конструктор копирования, конструктор перемещения, деструктор, оператор присваивания копированием, оператор присваивания перемещением. 

C++ не разрешает вызывать функцию main() внутри программы, в то время как в C это действие правомерно. 
Более того, код, верный для обоих языков, может давать разные результаты в зависимости от того, компилятором какого языка он оттранслирован. Так происходит из-за того, что символьные константы в C (например, 'a') имеют тип int, а в C++ — тип char, а размеры этих типов обычно различаются.

Средства C, которых рекомендуется избегать
1) Не использовать макроопределения #define. Для объявления констант применять const, групп констант (перечислений) — enum, для прямого включения функций — inline, для определения семейств функций или типов — template.
2) Не использовать предварительные объявления переменных. Объявлять переменные в блоке, где они реально используются, всегда совмещая объявление с инициализацией.
3) Отказаться от использования malloc() в пользу оператора new, от realloc() — в пользу типа vector. Более безопасным будет использование умных указателей, таких как shared_ptr и unique_ptr, доступных с одиннадцатой версии стандарта.
4) Избегать бестиповых указателей, арифметики указателей, неявных приведений типов, объединений, за исключением, возможно, низкоуровневого кода. Использовать «новые» преобразования типов, как более точно выражающие действительные намерения программиста и более безопасные.
5) Свести к минимуму использование массивов символов и строк в стиле C, заменив их на типы string и vector из STL. Вообще не стремиться создавать собственные реализации того, что уже имеется в стандартной библиотеке.

STL (Standard Template Library) - стандартная библиотека шаблонов.

#include <iostream> // для использования std::cout

В C++ (как и в C), если выполнение программы доходит до конца функции main(), то это эквивалентно return 0;. Это неверно для любой другой функции кроме main().

----------------
Операционные системы как Linux и macOS имеют уже встроенный компилятор C++, который называется g++.
// создадутся file1.o, file2.o и file3.o. -c означает «только скомпилировать», т.е. просто создать .o (объектные) файлы. 
g++ -c file1.cpp file2.cpp file3.cpp   
// -o сообщает g++, что мы хотим получить исполняемый файл с именем prog из файлов: file1.o, file2.o и file3.o.
g++ -o prog file1.o file2.o file3.o
// компиляцию и линкинг можно объединить в один шаг:
g++ -o prog file1.cpp file2.cpp file3.cpp
Исходный файл(.cpp) --> Обьектный файл (.о) --> Исполняемый файл

Консольные приложения (запускаются с командной строки) не имеют графического интерфейса пользователя (GUI) и компилируются в автономные исполняемые файлы.

Конфигурация сборки (build configuration):Release (релиз) и Debug (отладка).

Statement (стейтмент)
1) int х;               это statement declaration (операция объявления).
2) х = 5;               это assignment statement (операция присваивания).
3) std::cout << x;      это output statement (операция вывода).


#include <iostream>               // это специальный тип инструкции, который называется директивой препроцессора. 
 
int main()
{
   std::cout << "Hello, world!";
   return 0;                      // новый тип инструкции, который называется оператор возврата (return).
}

Программы на языке C++ создают, обрабатывают и уничтожают объекты. 
Объект — это часть памяти, которая может использоваться для хранения значений.
Все компьютеры имеют оперативную память (Random Access Memory – Оперативное Запоминающее Устройство), в народе просто «оперативка», которая доступна программам для использования. При определении объекта часть этой памяти выделяется для него. Большинство объектов, которые мы будем использовать в C++, представлены в виде переменных.

int x;
При выполнении этой инструкции центральным процессором (CPU) будет выделяться часть памяти ОЗУ (RAM). 
Например, предположим, что переменной х присваивается ячейка памяти под номером 170. Когда программа видит переменную х в выражении или стейтменте, она понимает, что нужно заглянуть в ячейку памяти 170, чтобы получить значение.

Если нужно вывести текст на нескольких строках – используйте std::endl. 
При использовании с std::cout, std::endl вставляет символ новой строки.

std::cout << 
std::cin >>

Если число больше/меньше допустимых максимумов/минимумов, то происходит переполнение (overflow).


При вызове функции, все параметры функции создаются как переменные, а значение каждого из аргументов копируется в соответствующий параметр. Этот процесс называется передачей по значению.
Например:
//#include "stdafx.h" // раскомментируйте, если используете Visual Studio
#include <iostream>
 
// Эта функция имеет два параметра типа int: a и b
// Значения для переменных a и b передаются caller-ом
void printValues(int a, int b)
{
   std::cout << a << std::endl;
   std::cout << b << std::endl;
}
 
int main()
{
   printValues(8, 9); // этот вызов функции имеет два аргумента: 8 и 9
 
   return 0;
}


Когда функция становится слишком большой, сложной или непонятной – её следует разбить на несколько подфункций. Это называется рефакторинг (refactoring).


Вот список всех ключевых слов в C++ (включая C++14):
 * — слова с одной звездочкой были добавлены в C++98. Некоторые учебники или справочники могут их пропускать.
** — слова с двумя звездочками были добавлены в C++11. Если ваш компилятор не поддерживает C++11, то они могут не работать.
C++11 также добавил два специальных идентификатора: override и final. Они имеют разные значения в разных контекстах.

alignas **
alignof **
and
and_eq
asm
auto
bitand
bitor
bool *
break
case
catch	char
char16_t **
char32_t **
class
compl
const
constexpr **
const_cast *
continue
decltype
default
delete	do
double
dynamic_cast *
else
enum
explicit *
export *
extern
false *
float
for
friend	goto
if
inline
int
long
mutable *
namespace *
new
noexcept **
not
not_eq
nullptr **	operator
or
or_eq
private
protected
public
register
reinterpret_cast *
return
short
signed
sizeof	static
static_assert **
static_cast *
struct
switch
template
this
thread_local **
throw
true *
try
typedef	typeid *
typename *
union
unsigned
using *
virtual
void
volatile
wchar_t *
while
xor
xor_eq

Идентификатор – это имя переменной, функции, класса или другого объекта в C++. 
В C++ имена переменных начинаются с буквы в нижнем регистре. 
Если имя переменной состоит из одного слова, то всё должно быть записано в нижнем регистре.
Имена идентификаторов, которые начинаются с заглавной буквы, используются для структур, классов и перечислений.


Операторы бывают трех типов:
- Унарные. Работают с одним операндом. Например, оператор «-» (минус). В выражении -7, оператор «-» применяется только к одному операнду (7), чтобы произвести новое значение (-7).
- Бинарные. Работают с двумя операндами (левым и правым). Например, оператор «+». В выражении 5 + 2, оператор «+» работает с левым операндом (5) и правым (2), чтобы произвести новое значение (7).
- Тернарные. Работают с тремя операндами. В C++ есть только один тернарный оператор.

В C++ к whitespaces можно отнести не только пробелы, но и символы табуляции и, иногда, перевод (разрыв) строки.

Исключением, где компилятор C++ обращает внимание на пустое пространство, является цитируемый текст, например: "Hello, world!".
"Hello, world!" отличается от "Hello,     world!"
Здесь пробелы уже учитываются.
Перевод строки (newline) не допускается в цитируемом тексте:
cout << "Hello
     world!" << endl; // Не допускается!
     

Вот несколько рекомендаций в основах форматирования:
1) Вместо TAB используйте 4 пробела.
Причиной использования пробелов вместо символов табуляции является то, что если вы откроете свой код в другом редакторе, он сохранит правильные отступы, в отличии от использования TAB.
2) Фигурные скобки, где функция начинается и заканчивается, должны находится на одном уровне в отдельных строках:
int main()
{
}
3) Каждая инструкция в фигурных скобках функции должна начинаться с одного таба от начала строки. Пример:
int main()
{
    cout << "Hello world!" << endl; // один таб (4 пробела)
    cout << "Nice to meet you." << endl; // один таб (4 пробела)
}
4) Линии не должны быть слишком длинными. Как правило, 72, 78 или 80 символов – это максимальная длина линии. Если строка будет длиннее, её следует разбить на несколько отдельных. Это выполняется с помощью одного дополнительного отступа для второй строки или, если линии похожи, новая строка + выравнивания.
int main()
{
    cout << "This is a really, really, really, really, really, really, really, " <<
        "really long line" << endl; // один дополнительный отступ для строки-продолжения

    cout << "This is another really, really, really, really, really, really, really, " <<
            "really long line" << endl; // отступ + выравнивание с учетом главной строки

    cout << "This one is short" << endl;
}
5) Если длинная линия разбита на части с помощью оператора (например, << или +), то оператор должен находится в конце этой же строки, а не в начале следующей. Так намного читабельнее.
6) Используйте пробел для улучшения читабельности вашего кода.
Сложно читать:
nCost = 57;
nPricePerItem = 24;
nValue = 5;
nNumberOfItems = 17;

Легче читать:
nCost          = 57;
nPricePerItem  = 24;
nValue         = 5;
nNumberOfItems = 17;

Для осуществления предварительного объявления используется особый стейтмент — прототип функции. Прототип функции состоит из возвращаемого типа, имени, параметров, но без основного тела (части между фигурными скобками). И так, как прототип функции – это инструкция, то она заканчивается точкой с запятой.
Вот программа, которая не компилировалась, но уже с прототипом функции в качестве предварительного объявления для аdd():

#include <iostream>

int add(int x, int y); // предварительное объявление add() (используя прототип функции)

int main()
{
    using namespace std;
    cout << "The sum of 3 and 4 is: " << add(3, 4) << endl; // это работает потому, что мы предварительно объявили функцию add() выше
    return 0;
}

int add(int x, int y) // даже если основная часть находится снизу
{
    return x + y;
}


Не пишите строчку: #include "add.cpp" в main.cpp. Это приведет к тому, что компилятор вставит содержимое add.cpp непосредственно в main.cpp вместо того, чтобы рассматривать их как отдельные файлы. Даже если это скомпилируется сейчас, позднее вы будете постоянно сталкиваться с проблемами, используя этот способ.


Заголовочный файл (файл заголовка, подключаемый файл или header file). Они имеют расширение .h, но иногда их можно увидеть и с расширением .hpp или вообще без расширения. Целью заголовочных файлов является удобное хранение предварительных объявлений для использования другими файлами.

Заголовочные файлы состоят из двух частей.
1 — header guard, об этом мы поговорим в следующем уроке (про препроцессоры). Header guards предотвращают вызовы (#includе) заголовочного файла больше одного раза с одного и того же файла.
2 – сам контент файла .h. В нем находятся предварительные объявления всех функций, которые мы будем в дальнейшем использовать. 

<>
используя угловые скобки, мы сообщаем компилятору, что подключаемый заголовочный файл написан не нами (он идет вместе с компилятором), так что искать этот header file нужно в системных директориях. 
""
Двойные кавычки сообщают компилятору, что мы подключаем заголовочный файл, который создали сами, поэтому искать его нужно в текущей директории, вместе с нашим исходным кодом. Если его там не окажется, то компилятор начнет проверять другие пути, в том числе и системные директории.

Когда вы подключаете заголовочный файл из стандартной библиотеки, убедитесь, что вы используете версию без .h (если она существует). В противном случае вы будете использовать устаревшую версию заголовка, который больше не поддерживается.


Плохой способ — записать относительный путь к файлу, который вы хотите подключить, как часть строки #include. Например:
#include "headers/myHeader.h"
#include "../moreHeaders/myOtherHeader.h"

С помощью G++, вы можете использовать опцию –I для указания альтернативного подключения директории:
g++ -o main -I /source/includes main.cpp
Плюсом этого подхода является то, что если когда-либо изменится структура ваших каталогов, вам нужно будет изменить только один параметр в компиляторе или IDE, вместо внесения изменений в каждый файла кода.


Директивы — это специфические команды, которые начинаются с символа # и заканчиваются вместе с новой строки (НЕ точкой с запятой). 
Есть несколько типов директив, которые мы рассмотрим:
1) #include <filename> или #include "filename"
2) #define
Директиву #define можно использовать для создания макросов. Макрос — это правило, которое определяет, как последовательность input (например, идентификатор) преобразуется в последовательность output (например, в какой-нибудь текст).
Есть два основных типа макросов: макросы-функции и макросы-объекты.
#define identifier                    // любое дальнейшее появление идентификатора удаляется и заменяется «ничем»!
#define identifier substitution_text
Верхнее определение не имеет никакого substitution text, в то время как нижнее имеет.

- Директива #ifdef позволяет препроцессору проверить, было ли значение ранее #define. Если да, то код между #ifdef и #endif скомпилируется. Если нет, то код игнорируется.
- #ifndef – полная противоположность к #ifdef и позволяет проверить, НЕ было ли значения ранее определено.

#define PRINT_JOE
 
#ifdef PRINT_JOE
std::cout << "Joe" << std::endl;
#endif
 
#ifdef PRINT_BOB
std::cout << "Bob" << std::endl;
#endif

Большинство компиляторов поддерживают более простую, альтернативную форму header guards — директиву #pragma:
#pragma once 
// ваш код здесь

Однако, #pragma once не является официальной частью языка C++, и не все компиляторы имеют её поддержку (хотя большинство современных компиляторов поддерживают).

В C++ перенесли всю функциональность со стандартной библиотеки в специальную область, которую назвали пространством имен (namespace).
std (сокращенно от «standard»)
Когда вы используете идентификатор с пространства имен, обязательно указывайте имя этого пространства имен.

Оператор разрешения области видимости ::
Самый простой способ сообщить компилятору, что cout находится в std namespace – использовать префикс «std::». Например:
   std::cout << "Hello world!";

return -1; // стандартное значение "error", если пользователь введет недействительный символ op

Ошибки, как правило, попадают в одну из двух категорий: 
- синтаксические или 
- семантические (смысловые) - возникает, когда код является синтаксически правильным, но делает не то, что задумал программист. Компилятор не может уловить подобные ошибки, так как он проверяет только то, что вы написали, а не то, что вы хотели этим сделать.

В большинстве других программах (свыше 40 строк), семантические ошибки уловить с помощью простого просмотра кода будет не так-то просто.
И здесь на помощь приходит отладчик.

1. Отладчик (debugger) — это компьютерная программа, которая позволяет программисту контролировать и смотреть выполнение программы.
Сейчас почти все современные IDE идут в комплекте со встроенными отладчиками.
2. Stepping (степпинг) — это возможность отладчика выполнять код строка за строкой (пошагово). Есть три разные команды stepping: step into, step over и step out. 
3. Run to cursor – это еще одна полезная команда. Здесь мы выполняем программу, как обычно, только до строки, которая обозначена курсором. Затем контроль переходит нам и мы можем проводить отладку с той точки уже более подробно.
4. Continue
Если вы находитесь в середине процесса отладки вашей программы, вы можете сообщить отладчику продолжать выполнение до тех пор, пока он не дойдет до конца программы (или следующей контрольной точки).
5. Breakpoints (точки останова) – это специальные маркеры, в местах размещения которых отладчик останавливает выполнение.
Breakpoints чрезвычайно полезны, если вы хотите изучить только определенную часть кода. 
6. Отслеживание переменных — это процесс проверки значений переменных во время отладки. 
7. Watch window (окно просмотра) – это окно, в которое можно добавлять переменные для постоянного отслеживания, они будут автоматически обновляться при выполнении программы, строка за строкой. Окно просмотра уже может быть в рабочей области вашей среды разработки, но если нет, то его можно подключить, используя команды IDE (смотрите в пунктах меню Debug или View).
Watch window — это лучший способ наблюдения за значениями переменных в ходе выполнения программы.
8. Стек вызовов (call stack ) — это список всех активных функций, которые вызывались, до текущей точки выполнения. Call stack включает запись каждой вызываемой функции, в том числе и линии, которая выполняется. Всякий раз, когда происходит вызов новой функции, эта функция добавляется в самый вверх стека. Когда выполнение текущей функции прекращается, она удаляется из верхней части стека и управление переходит к функции ниже (второй по счету).

------------------ Переменные и основные типы данных в C++ ------------------
Компьютеры имеют оперативную память (RAM), которая доступна программам для использования. Когда мы определяем переменную, часть этой памяти отводится специально ей.
Наименьшая единица памяти — бит (с англ. binary digit), который может содержать либо значение 0, либо значение 1. 
Если просмотреть случайный кусочек памяти, то всё, что вы увидите, будет …011010100101010… или что-то в этом роде. Память организована в последовательные части — адреса. 
В современных компьютерах, у каждого бита по отдельности нет своего собственного адреса. Наименьшей единицей, которой дается адрес, является байт (состоит из 8 битов).

C++ поддерживает два основных способа инициализации переменных. 
1 - copy initialization (копирующая инициализация) с помощью знака равенства:
          int nValue = 5; // копирующая инициализация
2 - direct initialization (прямая инициализация) с помощью круглых скобок.
          int nValue(5); // прямая инициализация
3 - uniform initialization (новая форма инициализации, которая добавляется в C++ 11):
          int value{5};
          int value{}; // инициализация по умолчанию - 0

С++ самым правильным считается определять переменные как можно ближе к их первому использованию.

void
Void, как правило, используется в немногих случаях:
1. Чаще всего, как способ указать, что функция не возвращает значение
2. В языке C, как способ указать, что функция не принимает никаких параметров:
int getValue(void) // здесь void означает, что функция не принимает никакие параметры 
{
    int x;
    std::cin >> x;
    return x;
}
Значение void-а как «никаких параметров» является пережитком с языка C. Следующий код равнозначен и более предпочтителен в C++:
int getValue() // пустые скобки параметров функции - это то же самое, что и void
{
    int x;
    std::cin >> x;
    return x;
}
3. Related to pointers

Объем памяти, который использует переменная, основывается на ее типе данных. Так как мы, как правило, получаем доступ к памяти через имена переменных, а не через адреса памяти, то компилятор имеет возможность скрывать от нас все детали работы с переменными разных размеров.
Каждый раз, когда мы объявляем переменную, небольшая часть этой свободной памяти выделяется до тех пор, пока переменная существует. Поскольку современные компьютеры имеют много памяти, то в большинстве случаев – это не проблема, особенно когда в программе всего лишь несколько переменных. Тем не менее, для программ, которые требуют большого количества переменных (например, 100 000), разница между использованием 1-байтовых или 8-байтовых переменных может быть значительной.

1) boolean	
      bool	1 байт	
2) character	
      char	1 байт	
      wchar_t	1 байт	
      char16_t	2 байта
      char32_t	4 байта
3) integer	
      short	2 байта
      int	2 байта	
      long	4 байта	
      long long	8 байтов
4) floating point	
      float	4 байта	
      double	8 байтов	
      long double	8 байтов
     
1 байт signed	      от -128 до 127
1 байт unsigned	    от 0 до 255
2 байта signed	    от -32 768 до 32 767
2 байта unsigned	  от 0 до 65 535
4 байта signed	    от -2 147 483 648 до 2 147 483 647
4 байта unsigned	  от 0 до 4 294 967 295
8 байтов signed	    от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
8 байтов unsigned	  от 0 до 18 446 744 073 709 551 615

Набор целочисленных типов фиксированной величины (fixed-width integers) - приняты только в C++ 11
int8_t	  1 байт signed	      от -128 до 127
uint8_t	  1 байт unsigned	    от 0 до 255
int16_t	  2 байта signed	    от -32 768 до 32 767
uint16_t	2 байта unsigned	  от 0 до 65 535
int32_t	  4 байта signed	    от -2 147 483 648 до 2 147 483 647
uint32_t	4 байта unsigned	  от 0 до 4 294 967 295
int64_t	  8 байтов signed	    от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
uint64_t	8 байтов unsigned	  от 0 до 18 446 744 073 709 551 615


sizeof — это один из трех операторов в C++, который является словом, а не символом. 
Два другие оператора – это new и delete.     

Тип char — особый случай, он относится как целочисленному, так и к символьному типам данных.

char c;
short int si; // официально
short s;      // предпочтительнее
int i;
long int li; // официально
long l;      // предпочтительнее
long long int lli; // официально
long long ll;      // предпочтительнее


signed (со знаком) означает, что переменная может содержать как положительные (плюсовые), так и отрицательные (минусовые) числа.
Целочисленный тип unsigned (без знака) может содержать только положительные значения. 
Все целочисленные типы, кроме char, являются signed по умолчанию. Char же может быть как со знаком, так и без него (но, обычно, signed).


Что произойдет, если мы попытаемся использовать значение, которое выходит за рамки диапазона определенного типа данных? Ответ: переполнение. Переполнение (overflow) означает потерю битов, так как переменной не было выделено достаточно памяти для их хранения.

число 21 занимает 5 битов (10101). 4 крайние правые биты (0101) перейдут в переменную, а крайний левый бит (1) просто потеряется. Тогда наша переменная станет 0101, что равно 101 (нуль спереди не считается), а это уже число 5, а не 21.

#include <iostream>
 
int main()
{
    unsigned short x = 65535; // наибольшее значение, которое может хранить 16-битовая unsigned переменная
    std::cout << "x was: " << x << std::endl;       // выведет x was: 65535
    x = x + 1; // 65536 - это число уже не в диапазоне, произойдет переполнение, так как x не может хранить 17 битов
    std::cout << "x is now: " << x << std::endl;    // выведет x is now: 0
    return 0;
}

Экспоненциальная запись
Числа в экспоненциальной записи имеют следующий вид: мантисса х 10экспонент. Например, рассмотрим выражение 1.2 x 104. Значение 1.2 – это мантисса (значащая часть), а 4 – это экспонент (порядок числа). Результат этого выражения: 12 000.

В C++ буква «е» или «Е» означает, все равно что «поднести число 10 к степени…». Например, 1.2 x 104 — эквивалентно 1.2e4 или 5.9736 x 1024 можно записать как 5.9736e24.
Для чисел, меньших единицы, экспонент может быть отрицательным. Например, 5e-2 эквивалентно 5 * 10-2, что в свою очередь 5 / 102 или 0,05.

На самом деле, мы можем использовать экспоненциальную запись для присвоения значений переменным типа с плавающей запятой.
double d1(5000.0);
double d2(5e3); // другой способ присвоить значение 5000
 
double d3(0.05);
double d4(5e-2); // другой способ присвоить значение 0.05

Самое главное, что нужно понять: цифры в мантиссе (части перед E) называются значащие цифры. Количество значащих цифр определяет точность самого числа. Чем больше цифр в мантиссе, тем точнее число.

Есть две специальные категории чисел типа с плавающей запятой. Первая — Inf, что значит infinity (бесконечность). Inf может быть положительной или отрицательной. Вторая — NaN, что значит “Not a Number” (не число).
INF означает бесконечность, а IND – неопределенность (indeterminate).

char
Для конвертации между основными типами данных (например, из char в int или наоборот) используется static cast.

Newline (\n) против std::endl. Что использовать?
-  используйте std::endl, когда нужно, чтобы ваши данные выводились немедленно (например: при написании записи в файл или при обновлении индикатора процесса). Обратите внимание, что этот вариант может повлечь незначительное снижение производительности, особенно если запись на устройство происходит медленно (например, запись файла на диск).
-  используйте ‘\n’ в остальных случаях.

Символы всегда помещаются в одинарные кавычки.
Текст, который находится в двойных кавычках, называется string (например, “Hello, world!”). string (строка) – это набор последовательных символов.

В C++ есть два вида констант: литеральные и символьные (символические). 
Литеральные константы (обычно просто литералы) – это значения, которые вставляются непосредственно в код. 
Символьная (или еще символическая) константа – это тот же литерал (магическое число), только с идентификатором. 

const double gravity { 9.8 }; // предпочтительнее использовать const перед типом данных
int const sidesInSquare { 4 }; // ок, но не предпочтительно


const является наиболее полезным (и наиболее часто используемым) с параметрами функций:
void printInteger(const int myValue)
{
    std::cout << myValue;
}
Таким образом, при вызове функции, константа-параметр говорит нам, что функция не будет изменять значение переменной myValue. Во-вторых, она гарантирует, что функция не изменит значение myValue.
--------------------
compile time
Когда вы находитесь в процессе компиляции программы – это compile time (время компиляции). Компилятор проверяет вашу программу на синтаксические ошибки, затем конвертирует код в объектные файлы.

runtime
Когда вы находитесь в процессе запуска вашей программы или когда программа уже выполняется — это runtime (время выполнения). Код выполняется строка за строкой.
--------------------

В C++ есть два вида констант.
Константы runtime. Их значения определяются только во время выполнения (когда программа запущена). 
Константы compile-time. Их значения определяются во время компиляции. Например, сила тяжести Земли – это константа compile-time, мы её определили сами в ходе написания программы.

ключевое слово constexpr гарантирует, что тип константы — compile-time.
Не используйте #define для создания символьных констант.

#ifndef CONSTANTS_H
#define CONSTANTS_H
 
// определите собственное пространство имен для хранения констант
namespace constants
{
    const double pi(3.14159);
    const double avogadro(6.0221413e23);
    const double my_gravity(9.2); 
    // ... другие константы 
}
#endif

Используйте оператор разрешения области видимости (::) для доступа к константам в файлах .cpp:
#include "constants.h"
double circumference = 2 * radius * constants::pi;

Почему символьные константы лучше литеральных (магических чисел)? Почему использование const лучше директив #define?
Ответ 1
Использование литеральных констант (магических чисел) не только усложняет программу, но и затрудняет внесение изменений. Символьные константы лучше тем, что они предоставляют контекст того, зачем они и для чего, также если понадобится внести изменения — достаточно будет внести правки только в объявлении константы, а не рыскать по всему коду. Константы #define не отображаются в отладчике, вероятность конфликта имен у них выше.

------------------------------------ Операторы в C++ ------------------------------------
------------------------------------ Область видимости и другие типы переменных в C++ ------------------------------------
------------------------------------ Порядок выполнения кода в программе. Циклы, ветвления в C++ ------------------------------------
------------------------------------ Массивы, Строки, Указатели и Ссылки в C++ ------------------------------------
------------------------------------ Функции в C++ ------------------------------------
------------------------------------ Основы ООП (Объектно-Ориентированного Программирования) в C++ ------------------------------------

объект в C++ - «часть памяти, которая используется для хранения значений». Объект с именем называется переменной.
Объекты имеют два основных компонента:
  Список соответствующих свойств (например: вес, цвет, размер, прочность, форма и т.д.).
  Поведение, которое они могут проявлять (например: открывать что-либо, делать что-то и т.д.).

В традиционном программировании, «объект» — это часть памяти для хранения значений. 
В объектно-ориентированном программировании, «объект» — это тот же объект, что и в традиционном программировании, но который соединяет в себе как свойства, так и способы поведения. 

Объектно-ориентированное программирование (ООП) предоставляет возможность создавать объекты, которые соединяют свойства и поведения в самостоятельный союз, который затем можно многоразово использовать. 
ДО ООР:     driveTo(you, work);
ПОСЛЕ ООР:  you.driveTo(work);

Концепции ООР: наследование, инкапсуляция, абстракция и полиморфизм.

Перечисления и структуры — это традиционный (не объектно-ориентированный) мир программирования, поскольку с их использованием мы можем только хранить данные.
Например, структура для хранения даты:
struct DateStruct
{
    int day;
    int month;
    int year;
};

В C++11 мы можем создать и инициализировать структуру следующим образом:
DateStruct today { 12, 11, 2018}; // используем uniform инициализацию

Класс
В мире объектно-ориентированного программирования типы данных могут не только содержать данные, но и функции, которые будут работать с этими данными. Для определения такого типа данных в C++ используется ключевое слово class.

В C++ классы очень похожи на структуры, за исключением того, что они обеспечивают гораздо большую мощность и гибкость. Фактически, следующая структура и класс по выполнению идентичны:

struct DateStruct
{
    int day;
    int month;
    int year;
};
 
class DateClass
{
public:
    int m_day;
    int m_month;
    int m_year;
};

Так же, как объявление структуры, объявление класса не приводит к выделению какой-либо памяти. Для использования класса нужно объявить переменную этого типа класса:
DateClass today { 12, 11, 2018 }; // объявляем переменную класса DateClass

В C++, переменная класса называется экземпляром или объектом класса.
Создание объекта класса (например, DateClass today) приводит к выделению памяти для этого объекта.

Точно так же, как к членам структуры, к членам (переменным и функциям) класса доступ осуществляется через оператор выбора членов (.):

Мы рекомендуем использовать ключевое слово struct для структур, используемых только для хранения данных и ключевое слово class для определения объектов, которые требуют объединения как данных, так и функций.

Стандартная библиотека C++ полна классов, созданных для вашего удобства. std::string, std::vector и std::array – это всё типы классов!

#include <string>
#include <array>
#include <vector>
#include <iostream>
 
int main()
{
    std::string s { "Hello, world!" }; // создаем экземпляр класса string
    std::array<int, 3> a { 7, 8, 9 }; // создаем экземпляр класса array
    std::vector<double> v { 1.5, 2.6, 3.7 }; // создаем экземпляр класса vector
 
    std::cout << "length: " << s.length() << '\n'; // вызываем метод 
 
    return 0;
}



------------------------------------ Перегрузка операторов в C++ ------------------------------------
------------------------------------ Введение в отношения между объектами в C++ ------------------------------------
------------------------------------ Наследование в C++ ------------------------------------
------------------------------------ Виртуальные функции в C++ ------------------------------------
------------------------------------ Шаблоны в C++ ------------------------------------
------------------------------------ Исключения в C++ ------------------------------------
------------------------------------ Умные указатели и Семантика перемещения в C++ ------------------------------------
------------------------------------ Стандартная библиотека шаблонов (STL) в С++ ------------------------------------
------------------------------------ std::string в С++ ------------------------------------
------------------------------------ Ввод/Вывод (I/O) в С++ ------------------------------------
