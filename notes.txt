http://www.cplusplus.com/doc/tutorial/
http://www.cplusplus.com/reference/iostream/
The compiler to use is clang++.

https://ravesli.com/uroki-cpp/
------------------------------------------------------------------------------------------------------------
D00 - C++ Basics
------------------------------------------------------------------------------------------------------------
INTRODUCTION
NAMESPACES
  Open main.cpp file.
  
  #include <stdio.h>
  int gl_var = 1;
  int f( void ) {return 2;}
  
  namespace Foo {
    int gl_var = 3;
    int f( void ) {return 4;}
  }
  
  namespace Bar {
    int gl_var = 5;
    int f( void ) {return 6;}
  }
  
  namespace Muf = Bar;
  
  int main(void) {
    printf("gl_var:   [%d]\n", gl_var);
    printf("f():      [%d]\n\n", f());
    
    // :: is scope resolution operator
    printf("Foo::gl_var:   [%d]\n", Foo::gl_var);
    printf("Foo::f():      [%d]\n\n", Foo::f());
    
    printf("Bar::gl_var:   [%d]\n", Bar::gl_var);
    printf("Bar::f():      [%d]\n\n", Bar::f());
    
    printf("Muf::gl_var:   [%d]\n", Muf::gl_var);
    printf("Muf::f():      [%d]\n\n", Muf::f());
    
    printf("::gl_var:   [%d]\n", ::gl_var); // the output of '::gl_var' will be the same as 'gl_var'.
    printf("::f():      [%d]\n\n", ::f());  
    
    return 0;
  }
  
  To compile: g++ -Wall -Wextra -Wno-used -Werror main.cpp
  To run: ./a.out
  
STDIO STREAMS
  Let's see how c++ handles inputs & outputs
  
  Open main.cpp (to test)
  
  #include <iostream>
  int main(void) {
    char buff[512];
    std::cout << "Hello world !" << std::endl;
    std::cout << "Input a word: ";
    std::cin >> buff;
    std::cout << "You entered: [" << buff << "]" << std::endl;
    return 0;
  }

CLASS AND INSTANCE
  Open Sample.class.h (to declare the class and f-ns and attributes)
  
  #ifndef SAMPLE_CLASS_H
  # define SAMPLE_CLASS_H
  class Sample {
  public: 
    Sample(void);       // declaration of constructor
    ~Sample(void);      // declaration of destructor
  };
  #endif
  
  Open Sample.class.cpp (to define these f-ns present in class)
  
  #include <iostream>
  #include "Sample.class.hpp"
  Sample::Sample(void){
    std::cout << "Constructor called" << std::endl;
    return;
  }
  Sample::~Sample(void){
    std::cout << "Destructor called" << std::endl;
    return;
  }
  
  Open main.cpp. 
  Let's see how to create instance. 
  
  #include "Sample.class.hpp"
  int main() {
    Sample instance;
    return 0;
  }

MEMBER ATTRIBUTES AND MEMBER FUNCTIONS
    Now that we know how to declare class and implement its constructor and its destructor, 
    we'll discover how to put things in our class to make it more useful. We'll discover the notion of member attribute and member f-n.
    A member attribute is just variable you have in your class and you may use from an instance.
    A member f-n is a f-n in my class that I'll be able to use from the instance of my class.
    In C, if we want to add a f-n to our structure - it would be impossible in C, the only way to do it is to have a pointer 
    on a f-n in our structure.
    In C++, we have a possibility to declare directly a f-n in our class. The implementation of this f-n as well as its definition
    work the same way as a constructor and a desctructor but this time we'll have a return type in front.
    
    Open Sample.class.h 
  
    #ifndef SAMPLE_CLASS_H
    # define SAMPLE_CLASS_H
    class Sample {
    public: 
      int foo;        // (member attribute) declaration of integer variable named foo
      Sample(void);
      ~Sample(void);
      void bar(void); // member f-n (will be usuful when the class will be instanciated)
    };
    #endif

    Open Sample.class.cpp 

    #include <iostream>
    #include "Sample.class.hpp"
    Sample::Sample(void){
      std::cout << "Constructor called" << std::endl;
      return;
    }
    Sample::~Sample(void){
      std::cout << "Destructor called" << std::endl;
      return;
    }
    //
    void Sample::bar(void) {
      std::cout << "Member f-n bar called" << std::endl;
      return;
    }
    
    Open main.cpp
  
    #include "Sample.class.hpp"
    int main() {
      Sample instance;
      instance.foo = 42;
      std::cout << "instance.foo: " << instance.foo << std:endl;
      instance.bar();   // to call member f-n
      return 0;
    }
    //so instance is stack variable
    
    
THIS
  this is a pointer to current instance
  
  Open Sample.class.cpp 

    #include <iostream>
    #include "Sample.class.hpp"
    Sample::Sample(void){
      std::cout << "Constructor called" << std::endl;
      this->foo = 42;
      std::cout << "this->foo: " << this->foo << std::endl;
      this->bar();
      return;
    }
    Sample::~Sample(void){
      std::cout << "Destructor called" << std::endl;
      return;
    }
    //
    void Sample::bar(void) {
      std::cout << "Member f-n bar called" << std::endl;
      return;
    }
    
    // To compile: g++ -Wall -Wextra -Wno-used -Werror Sample.class.cpp main.cpp
  
  
INITIALIZATION LIST
    Open Sample1.class.h 
  
    #ifndef SAMPLE1_CLASS_H
    # define SAMPLE1_CLASS_H
    class Sample1 {
    public: 
      // attributes
      char a1;
      int a2;
      float a3;
      
      Sample1(char p1, int p2, float p3);  // constructor's parameters
      ~Sample1(void);
      
    };
    #endif  
    
    Open Sample2.class.cpp 

    #include <iostream>
    #include "Sample2.class.hpp"
    // here I use a syntax called initialization list
    Sample2::Sample2(char p1, int p2, float p3) : a1(p1), a2(p2), a3(p3){
      std::cout << "Constructor called" << std::endl;
      std::cout << "this->a1: " << this->a1 << std::endl;
      std::cout << "this->a2: " << this->a2 << std::endl;
      std::cout << "this->a3: " << this->a3 << std::endl;
      return;
    }
    Sample2::~Sample2(void){
      std::cout << "Destructor called" << std::endl;
      return;
    }
    
    // use syntax from above - not from below
    Sample1::Sample1(char p1, int p2, float p3) {
      std::cout << "Constructor called" << std::endl;
      this->a1 = p1;
      std::cout << "this->a1: " << this->a1 << std::endl;
      this->a2 = p2;
      std::cout << "this->a2: " << this->a2 << std::endl;
      this->a3 = p3;
      std::cout << "this->a3: " << this->a3 << std::endl;
      return;
    }
    
    Open main.cpp
    #include <iostream>
    #include "Sample1.class.hpp"
    #include "Sample2.class.hpp"
    int main() {
      Sample1 instance1 ('a', 42, 4.2f);
      Sample2 instance2 ('z', 13, 3.14f);
      return 0;
    }
    
    // To compile: g++ -Wall -Wextra -Wno-used -Werror Sample1.class.cpp Sample2.class.cpp main.cpp
    
CONST
  We can't assign value to const, we can only initialize const to the value
  
  Open Sample1.class.h 
  
    #ifndef SAMPLE_CLASS_H
    # define SAMPLE_CLASS_H
    class Sample {
    public: 
      float const pi;
      int         qd;
      
      Sample(float const f);  
      ~Sample(void);
      void bar(void) const;
    };
    #endif  
    
    Open Sample.class.cpp 

    #include <iostream>
    #include "Sample.class.hpp"
    Sample::Sample(float const f) : pi(f), qd(42){
      std::cout << "Constructor called" << std::endl;
      return;
    }
    Sample::~Sample(void){
      std::cout << "Destructor called" << std::endl;
      return;
    }
    void Sample::bar(void) const {
      std::cout << "this->pi: " << this->pi << std::endl; 
      std::cout << "this->qd: " << this->qd << std::endl;
      //this->qd = 0; // read-only error
      return;
    }
    
    
VISIBILITY
  public and private keywords wil allow me to control encapsulation of the members of our class.
  That means Members attributes and f-ns will be visible from inside of class or from outside.
  Use undescore for private.
  If you try to access private attribute or f-n - it won't compile.
  
CLASS VS STRUCT
  Structures(but without specifying public/private which won't lead to error in compiling) have the same syntax as classes. 
  Structures and classes works in the same way in C++. It's all about outputs.
  So, The difference is that the scope in structures is public by default. 
  
    #ifndef SAMPLE1_CLASS_H
    # define SAMPLE1_CLASS_H
    struct Sample1 {
    public: 
      int  foo;
      
      Sample1(void);  
      ~Sample1(void);
      void bar(void) const;
    };
    #endif 
  
ACCESSORS
    get, getFoo [get followed by a name of getter]
    set
    
    Open Sample.class.cpp
    ..
    public: 
      Sample1(void);  
      ~Sample1(void);
      int getFoo(void) const;
      void setFoo(int v);
    };
    private:
      int _foo;
    ..
    
    Open Sample.class.php
    ....
    int Sample::getFoo(void) const {
      return this->_foo;
    }
    int Sample::setFoo(int v) {
      if (v >= 0)
          this->_foo = v;
      return;
    }
    
COMPARISONS
  == 
  
  if (&instance1 == &instance1) 
      std::count << "instance1 and instance1 are physically equal" << std:endl;
  if (&instance1.compare(&instance1) == 0) 
      std::count << "instance1 and instance1 are structurally equal" << std:endl;
    
NON MEMBER ATTRIBUTES AND NON MEMBER FUNCTIONS
    Open Sample.class.cpp
    ..
    public: 
      Sample1(void);  
      ~Sample1(void);
      static int getNbInst(void);
    };
    private:
      static int _nbInst;
    ..
    
POINTERS TO MEMBERS

CONCLUSION

------------------------------------------------------------------------------------------------------------
D01 - C++ Basics 2
------------------------------------------------------------------------------------------------------------
NEW AND DELETE
    Memory management 
    In C, you used malloc(); In C++, you also can but it's a bad idea.
    
    #include <string>
    class Student {
      private:
          std:: string _login;
      public:
          // Student() : _login("ldefault")
          Student(std:: string login) : _login(login);
          {
              std:: count << "Student " << this->_login << "is born" << std::endl;
          }
          ~Student();
          {
              std:: count << "Student " << this->_login << "is died" << std::endl;
          }
    };
    int main() {
        // Student* students = new Student[42];
        Student bob = Student("bfubar");
        Student* jim = new Student("jfubar");
        // Do some stuff here
        // deallocate, there used to be malloc free, now it's delete
        // delete [] students;
        delete jim;   //jim is destroyed
        return 0;     // bob is destroyed
    }
    
REFERENCES
    Now let's talk about new C++ concept - references.
    We'll do comparison to pointers in C.
    
    https://www.geeksforgeeks.org/pointers-vs-references-cpp/
    
    Pointers: A pointer is a variable that holds memory address of another variable. A pointer needs to be dereferenced with * operator to access the memory location it points to.

    References : A reference variable is an alias, that is, another name for an already existing variable. A reference, like a pointer is also implemented by storing the address of an object.
A reference can be thought of as a constant pointer (not to be confused with a pointer to a constant value!) with automatic indirection, i.e the compiler will apply the * operator for you.
    
    int i = 3; 

    // A pointer to variable i (or stores
    // address of i)
    int *ptr = &i; 

    // A reference (or alias) for i.
    int &ref = i; 

    
    Use references
        - In function parameters and return types.
    Use pointers:
        - Use pointers if  pointer arithmetic or passing NULL-pointer is needed. For example for arrays (Note that array access is
        implemented using pointer arithmetic).
        - To implement data structures like linked list, tree, etc and their algorithms because to point different cell,we have to 
        use the concept of pointers.

    
FILESTREAM
  how to use input/outputs to make actions in files.
  ifstream - input file stream
  ofstream - output file stream
  
  Open fstream1.cpp
  
  #include <iostream>
  #include <fstream>
  int main() {
      std::ifstream   ifs("numbers");
      unsigned int    dst;
      unsigned int    dst2;
      ifs >> dst >> dst2;
      std::count << dst << " " << dst2 << std::endl;
      ifs.close();
      //------------
      std::ofstream   ifs("test.out");
      ofs << "i like ponies" << std::endl;
      ofs.close();
  }
  
  To compile: g++ fstream1.cpp
  ./a.out
  cat test.out
  rm test.out
  
------------------------------------------------------------------------------------------------------------
D02
------------------------------------------------------------------------------------------------------------
INTRODUCTION
AD-HOC POLYMORPHISM
    Function overloading. 
    Principle: you have 1 f-n name and different parameters for overload - this will allow you to specialize the process of a f-n
    based on parameters.
    
    Open Sample.class.h
  
    #ifndef SAMPLE_CLASS_H
    # define SAMPLE_CLASS_H
    class Sample {
    public: 
      Sample(void);       
      ~Sample(void);      
      // below you see 4 bar overloads
      void bar(char const c) const;
      void bar(int const n) const;
      void bar(float const z) const;
      void bar(Sample const & i) const;
    };
    #endif
    
    Open Sample.class.cpp
    ..
    void Sample::bar(char const c) const {
      std:: count << "Member f-n bar called with char overload" << std::endl;   
      return;
    }
    void Sample::bar(int const n) const {
      std:: count << "Member f-n bar called with int overload" << std::endl;   
      return;
    }
    void Sample::bar(float const z) const {
      std:: count << "Member f-n bar called with float overload" << std::endl;   
      return;
    }
    void Sample::bar(Sample const & i) const {
      std:: count << "Member f-n bar called with Sample class overload" << std::endl;   
      return;
    }
    ..
    
    
OPERATOR OVERLOAD
    + 1 1 prefix (functional notation) 
    + (1, 1)
    1.+( 1 ) plus member f-n
    
    1 + 1 infix notation
    1 1 + postfix (stack calculation) (pulish reverse notation ??)
    ...
    
CANONICAL FORM
    coplin??
    
    From now on, each class you write MUST be in canonical form : 
    	- At least one default constructor, 
	- a copy contructor, 
	- an assignation operator overload and 
	- a destructor.
    
CONCLUSION

------------------------------------------------------------------------------------------------------------
D03 - Inheritance
------------------------------------------------------------------------------------------------------------
INHERITANCE C++

------------------------------------------------------------------------------------------------------------
D04 - Sub-typing polymorphism
------------------------------------------------------------------------------------------------------------
SUB-TYPING POLYMORPHISM
ABSTRACT CLASSES AND INTERFACES

------------------------------------------------------------------------------------------------------------
D05 - Nested classes and Exceptions
------------------------------------------------------------------------------------------------------------
NESTED CLASSES
EXCEPTIONS

------------------------------------------------------------------------------------------------------------
D06 - Casts
------------------------------------------------------------------------------------------------------------
INTRODUCTION
FROM C - TYPE CONVERSION
FROM C - TYPE REINTERPRETATION
FROM C - TYPE QUALIFIER REINTERPRETATION
UPCAST AND DOWNCAST
STATIC CAST
DYNAMIC CAST
REINTERPRET CAST
CONST CAST
CAST OPERATORS
EXPLICIT KEYWORD
CONCLUSION

------------------------------------------------------------------------------------------------------------
D07 - Templates
------------------------------------------------------------------------------------------------------------
INTRODUCTION
TEMPLATES
DEFAULT TYPE
SPECIALIZATION
CONCLUSION
FROM C - PARAMETRIC MACROS

------------------------------------------------------------------------------------------------------------
D08 - STL
------------------------------------------------------------------------------------------------------------
STL

------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
MY NOTES

Для работы с памятью введены операторы new, new[], delete и delete[]. В отличие от библиотечных malloc и free, пришедших из C, данные операторы производят инициализацию объекта. Для классов это вызов конструктора, для POD типов инициализацию можно либо не проводить(new Pod;), либо провести инициализацию нулевыми значениями (new Pod(); new Pod{};).


Типы
- Символьные: char, wchar_t (char16_t и char32_t, в стандарте C++11).
- Целочисленные знаковые: signed char, short int, int, long int (и long long, в стандарте C++11).
- Целочисленные беззнаковые: unsigned char, unsigned short int, unsigned int, unsigned long int(и unsigned long long, в стандарте C++11).
- С плавающей точкой: float, double, long double.
- Логический: bool, имеющий значения true или false.

В стандарте C++ под классом (class) подразумевается пользовательский тип, объявленный с использованием одного из ключевых слов class, struct или union, под структурой (structure) подразумевается класс, определённый через ключевое слово struct, и под объединением (union) подразумевается класс, определённый через ключевое слово union.

В теле определения класса можно указать как объявления функций, так и их определение. В последнем случае функция является встраиваемой (inline)). Нестатические функции-члены могут иметь квалификаторы const и volatile, а также ссылочный квалификатор (& или &&).

Друзья
Функции-друзья — это функции, не являющиеся функциями-членами и тем не менее имеющие доступ к защищённым и закрытым членам класса. Они должны быть объявлены в теле класса как friend. Например:

class Matrix {
    friend Matrix Multiply(Matrix m1, Matrix m2);
};
Здесь функция Multiply может обращаться к любым полям и функциям-членам класса Matrix.

Класс по умолчанию может иметь шесть специальных функций: конструктор по умолчанию, конструктор копирования, конструктор перемещения, деструктор, оператор присваивания копированием, оператор присваивания перемещением. 

C++ не разрешает вызывать функцию main() внутри программы, в то время как в C это действие правомерно. 
Более того, код, верный для обоих языков, может давать разные результаты в зависимости от того, компилятором какого языка он оттранслирован. Так происходит из-за того, что символьные константы в C (например, 'a') имеют тип int, а в C++ — тип char, а размеры этих типов обычно различаются.

Средства C, которых рекомендуется избегать
1) Не использовать макроопределения #define. Для объявления констант применять const, групп констант (перечислений) — enum, для прямого включения функций — inline, для определения семейств функций или типов — template.
2) Не использовать предварительные объявления переменных. Объявлять переменные в блоке, где они реально используются, всегда совмещая объявление с инициализацией.
3) Отказаться от использования malloc() в пользу оператора new, от realloc() — в пользу типа vector. Более безопасным будет использование умных указателей, таких как shared_ptr и unique_ptr, доступных с одиннадцатой версии стандарта.
4) Избегать бестиповых указателей, арифметики указателей, неявных приведений типов, объединений, за исключением, возможно, низкоуровневого кода. Использовать «новые» преобразования типов, как более точно выражающие действительные намерения программиста и более безопасные.
5) Свести к минимуму использование массивов символов и строк в стиле C, заменив их на типы string и vector из STL. Вообще не стремиться создавать собственные реализации того, что уже имеется в стандартной библиотеке.

STL (Standard Template Library) - стандартная библиотека шаблонов.

#include <iostream> // для использования std::cout

В C++ (как и в C), если выполнение программы доходит до конца функции main(), то это эквивалентно return 0;. Это неверно для любой другой функции кроме main().

----------------
Операционные системы как Linux и macOS имеют уже встроенный компилятор C++, который называется g++.
// создадутся file1.o, file2.o и file3.o. -c означает «только скомпилировать», т.е. просто создать .o (объектные) файлы. 
g++ -c file1.cpp file2.cpp file3.cpp   
// -o сообщает g++, что мы хотим получить исполняемый файл с именем prog из файлов: file1.o, file2.o и file3.o.
g++ -o prog file1.o file2.o file3.o
// компиляцию и линкинг можно объединить в один шаг:
g++ -o prog file1.cpp file2.cpp file3.cpp
Исходный файл(.cpp) --> Обьектный файл (.о) --> Исполняемый файл

Консольные приложения (запускаются с командной строки) не имеют графического интерфейса пользователя (GUI) и компилируются в автономные исполняемые файлы.

Конфигурация сборки (build configuration):Release (релиз) и Debug (отладка).

Statement (стейтмент)
1) int х;               это statement declaration (операция объявления).
2) х = 5;               это assignment statement (операция присваивания).
3) std::cout << x;      это output statement (операция вывода).


#include <iostream>               // это специальный тип инструкции, который называется директивой препроцессора. 
 
int main()
{
   std::cout << "Hello, world!";
   return 0;                      // новый тип инструкции, который называется оператор возврата (return).
}

Программы на языке C++ создают, обрабатывают и уничтожают объекты. 
Объект — это часть памяти, которая может использоваться для хранения значений.
Все компьютеры имеют оперативную память (Random Access Memory – Оперативное Запоминающее Устройство), в народе просто «оперативка», которая доступна программам для использования. При определении объекта часть этой памяти выделяется для него. Большинство объектов, которые мы будем использовать в C++, представлены в виде переменных.

int x;
При выполнении этой инструкции центральным процессором (CPU) будет выделяться часть памяти ОЗУ (RAM). 
Например, предположим, что переменной х присваивается ячейка памяти под номером 170. Когда программа видит переменную х в выражении или стейтменте, она понимает, что нужно заглянуть в ячейку памяти 170, чтобы получить значение.

Если нужно вывести текст на нескольких строках – используйте std::endl. 
При использовании с std::cout, std::endl вставляет символ новой строки.

std::cout << 
std::cin >>

Если число больше/меньше допустимых максимумов/минимумов, то происходит переполнение (overflow).


При вызове функции, все параметры функции создаются как переменные, а значение каждого из аргументов копируется в соответствующий параметр. Этот процесс называется передачей по значению.
Например:
//#include "stdafx.h" // раскомментируйте, если используете Visual Studio
#include <iostream>
 
// Эта функция имеет два параметра типа int: a и b
// Значения для переменных a и b передаются caller-ом
void printValues(int a, int b)
{
   std::cout << a << std::endl;
   std::cout << b << std::endl;
}
 
int main()
{
   printValues(8, 9); // этот вызов функции имеет два аргумента: 8 и 9
 
   return 0;
}


Когда функция становится слишком большой, сложной или непонятной – её следует разбить на несколько подфункций. Это называется рефакторинг (refactoring).


Вот список всех ключевых слов в C++ (включая C++14):
 * — слова с одной звездочкой были добавлены в C++98. Некоторые учебники или справочники могут их пропускать.
** — слова с двумя звездочками были добавлены в C++11. Если ваш компилятор не поддерживает C++11, то они могут не работать.
C++11 также добавил два специальных идентификатора: override и final. Они имеют разные значения в разных контекстах.

alignas **
alignof **
and
and_eq
asm
auto
bitand
bitor
bool *
break
case
catch	char
char16_t **
char32_t **
class
compl
const
constexpr **
const_cast *
continue
decltype
default
delete	do
double
dynamic_cast *
else
enum
explicit *
export *
extern
false *
float
for
friend	goto
if
inline
int
long
mutable *
namespace *
new
noexcept **
not
not_eq
nullptr **	operator
or
or_eq
private
protected
public
register
reinterpret_cast *
return
short
signed
sizeof	static
static_assert **
static_cast *
struct
switch
template
this
thread_local **
throw
true *
try
typedef	typeid *
typename *
union
unsigned
using *
virtual
void
volatile
wchar_t *
while
xor
xor_eq

Идентификатор – это имя переменной, функции, класса или другого объекта в C++. 
В C++ имена переменных начинаются с буквы в нижнем регистре. 
Если имя переменной состоит из одного слова, то всё должно быть записано в нижнем регистре.
Имена идентификаторов, которые начинаются с заглавной буквы, используются для структур, классов и перечислений.


Операторы бывают трех типов:
- Унарные. Работают с одним операндом. Например, оператор «-» (минус). В выражении -7, оператор «-» применяется только к одному операнду (7), чтобы произвести новое значение (-7).
- Бинарные. Работают с двумя операндами (левым и правым). Например, оператор «+». В выражении 5 + 2, оператор «+» работает с левым операндом (5) и правым (2), чтобы произвести новое значение (7).
- Тернарные. Работают с тремя операндами. В C++ есть только один тернарный оператор.

В C++ к whitespaces можно отнести не только пробелы, но и символы табуляции и, иногда, перевод (разрыв) строки.

Исключением, где компилятор C++ обращает внимание на пустое пространство, является цитируемый текст, например: "Hello, world!".
"Hello, world!" отличается от "Hello,     world!"
Здесь пробелы уже учитываются.
Перевод строки (newline) не допускается в цитируемом тексте:
cout << "Hello
     world!" << endl; // Не допускается!
     

Вот несколько рекомендаций в основах форматирования:
1) Вместо TAB используйте 4 пробела.
Причиной использования пробелов вместо символов табуляции является то, что если вы откроете свой код в другом редакторе, он сохранит правильные отступы, в отличии от использования TAB.
2) Фигурные скобки, где функция начинается и заканчивается, должны находится на одном уровне в отдельных строках:
int main()
{
}
3) Каждая инструкция в фигурных скобках функции должна начинаться с одного таба от начала строки. Пример:
int main()
{
    cout << "Hello world!" << endl; // один таб (4 пробела)
    cout << "Nice to meet you." << endl; // один таб (4 пробела)
}
4) Линии не должны быть слишком длинными. Как правило, 72, 78 или 80 символов – это максимальная длина линии. Если строка будет длиннее, её следует разбить на несколько отдельных. Это выполняется с помощью одного дополнительного отступа для второй строки или, если линии похожи, новая строка + выравнивания.
int main()
{
    cout << "This is a really, really, really, really, really, really, really, " <<
        "really long line" << endl; // один дополнительный отступ для строки-продолжения

    cout << "This is another really, really, really, really, really, really, really, " <<
            "really long line" << endl; // отступ + выравнивание с учетом главной строки

    cout << "This one is short" << endl;
}
5) Если длинная линия разбита на части с помощью оператора (например, << или +), то оператор должен находится в конце этой же строки, а не в начале следующей. Так намного читабельнее.
6) Используйте пробел для улучшения читабельности вашего кода.
Сложно читать:
nCost = 57;
nPricePerItem = 24;
nValue = 5;
nNumberOfItems = 17;

Легче читать:
nCost          = 57;
nPricePerItem  = 24;
nValue         = 5;
nNumberOfItems = 17;

Для осуществления предварительного объявления используется особый стейтмент — прототип функции. Прототип функции состоит из возвращаемого типа, имени, параметров, но без основного тела (части между фигурными скобками). И так, как прототип функции – это инструкция, то она заканчивается точкой с запятой.
Вот программа, которая не компилировалась, но уже с прототипом функции в качестве предварительного объявления для аdd():

#include <iostream>

int add(int x, int y); // предварительное объявление add() (используя прототип функции)

int main()
{
    using namespace std;
    cout << "The sum of 3 and 4 is: " << add(3, 4) << endl; // это работает потому, что мы предварительно объявили функцию add() выше
    return 0;
}

int add(int x, int y) // даже если основная часть находится снизу
{
    return x + y;
}


Не пишите строчку: #include "add.cpp" в main.cpp. Это приведет к тому, что компилятор вставит содержимое add.cpp непосредственно в main.cpp вместо того, чтобы рассматривать их как отдельные файлы. Даже если это скомпилируется сейчас, позднее вы будете постоянно сталкиваться с проблемами, используя этот способ.


Заголовочный файл (файл заголовка, подключаемый файл или header file). Они имеют расширение .h, но иногда их можно увидеть и с расширением .hpp или вообще без расширения. Целью заголовочных файлов является удобное хранение предварительных объявлений для использования другими файлами.

Заголовочные файлы состоят из двух частей.
1 — header guard, об этом мы поговорим в следующем уроке (про препроцессоры). Header guards предотвращают вызовы (#includе) заголовочного файла больше одного раза с одного и того же файла.
2 – сам контент файла .h. В нем находятся предварительные объявления всех функций, которые мы будем в дальнейшем использовать. 

<>
используя угловые скобки, мы сообщаем компилятору, что подключаемый заголовочный файл написан не нами (он идет вместе с компилятором), так что искать этот header file нужно в системных директориях. 
""
Двойные кавычки сообщают компилятору, что мы подключаем заголовочный файл, который создали сами, поэтому искать его нужно в текущей директории, вместе с нашим исходным кодом. Если его там не окажется, то компилятор начнет проверять другие пути, в том числе и системные директории.

Когда вы подключаете заголовочный файл из стандартной библиотеки, убедитесь, что вы используете версию без .h (если она существует). В противном случае вы будете использовать устаревшую версию заголовка, который больше не поддерживается.


Плохой способ — записать относительный путь к файлу, который вы хотите подключить, как часть строки #include. Например:
#include "headers/myHeader.h"
#include "../moreHeaders/myOtherHeader.h"

С помощью G++, вы можете использовать опцию –I для указания альтернативного подключения директории:
g++ -o main -I /source/includes main.cpp
Плюсом этого подхода является то, что если когда-либо изменится структура ваших каталогов, вам нужно будет изменить только один параметр в компиляторе или IDE, вместо внесения изменений в каждый файла кода.


Директивы — это специфические команды, которые начинаются с символа # и заканчиваются вместе с новой строки (НЕ точкой с запятой). 
Есть несколько типов директив, которые мы рассмотрим:
1) #include <filename> или #include "filename"
2) #define
Директиву #define можно использовать для создания макросов. Макрос — это правило, которое определяет, как последовательность input (например, идентификатор) преобразуется в последовательность output (например, в какой-нибудь текст).
Есть два основных типа макросов: макросы-функции и макросы-объекты.
#define identifier                    // любое дальнейшее появление идентификатора удаляется и заменяется «ничем»!
#define identifier substitution_text
Верхнее определение не имеет никакого substitution text, в то время как нижнее имеет.

- Директива #ifdef позволяет препроцессору проверить, было ли значение ранее #define. Если да, то код между #ifdef и #endif скомпилируется. Если нет, то код игнорируется.
- #ifndef – полная противоположность к #ifdef и позволяет проверить, НЕ было ли значения ранее определено.

#define PRINT_JOE
 
#ifdef PRINT_JOE
std::cout << "Joe" << std::endl;
#endif
 
#ifdef PRINT_BOB
std::cout << "Bob" << std::endl;
#endif

Большинство компиляторов поддерживают более простую, альтернативную форму header guards — директиву #pragma:
#pragma once 
// ваш код здесь

Однако, #pragma once не является официальной частью языка C++, и не все компиляторы имеют её поддержку (хотя большинство современных компиляторов поддерживают).

В C++ перенесли всю функциональность со стандартной библиотеки в специальную область, которую назвали пространством имен (namespace).
std (сокращенно от «standard»)
Когда вы используете идентификатор с пространства имен, обязательно указывайте имя этого пространства имен.

Оператор разрешения области видимости ::
Самый простой способ сообщить компилятору, что cout находится в std namespace – использовать префикс «std::». Например:
   std::cout << "Hello world!";

return -1; // стандартное значение "error", если пользователь введет недействительный символ op

Ошибки, как правило, попадают в одну из двух категорий: 
- синтаксические или 
- семантические (смысловые) - возникает, когда код является синтаксически правильным, но делает не то, что задумал программист. Компилятор не может уловить подобные ошибки, так как он проверяет только то, что вы написали, а не то, что вы хотели этим сделать.

В большинстве других программах (свыше 40 строк), семантические ошибки уловить с помощью простого просмотра кода будет не так-то просто.
И здесь на помощь приходит отладчик.

1. Отладчик (debugger) — это компьютерная программа, которая позволяет программисту контролировать и смотреть выполнение программы.
Сейчас почти все современные IDE идут в комплекте со встроенными отладчиками.
2. Stepping (степпинг) — это возможность отладчика выполнять код строка за строкой (пошагово). Есть три разные команды stepping: step into, step over и step out. 
3. Run to cursor – это еще одна полезная команда. Здесь мы выполняем программу, как обычно, только до строки, которая обозначена курсором. Затем контроль переходит нам и мы можем проводить отладку с той точки уже более подробно.
4. Continue
Если вы находитесь в середине процесса отладки вашей программы, вы можете сообщить отладчику продолжать выполнение до тех пор, пока он не дойдет до конца программы (или следующей контрольной точки).
5. Breakpoints (точки останова) – это специальные маркеры, в местах размещения которых отладчик останавливает выполнение.
Breakpoints чрезвычайно полезны, если вы хотите изучить только определенную часть кода. 
6. Отслеживание переменных — это процесс проверки значений переменных во время отладки. 
7. Watch window (окно просмотра) – это окно, в которое можно добавлять переменные для постоянного отслеживания, они будут автоматически обновляться при выполнении программы, строка за строкой. Окно просмотра уже может быть в рабочей области вашей среды разработки, но если нет, то его можно подключить, используя команды IDE (смотрите в пунктах меню Debug или View).
Watch window — это лучший способ наблюдения за значениями переменных в ходе выполнения программы.
8. Стек вызовов (call stack ) — это список всех активных функций, которые вызывались, до текущей точки выполнения. Call stack включает запись каждой вызываемой функции, в том числе и линии, которая выполняется. Всякий раз, когда происходит вызов новой функции, эта функция добавляется в самый вверх стека. Когда выполнение текущей функции прекращается, она удаляется из верхней части стека и управление переходит к функции ниже (второй по счету).

------------------------------------------------------------------------------------------------------------
------------------ Переменные и основные типы данных в C++ ------------------
------------------------------------------------------------------------------------------------------------

Компьютеры имеют оперативную память (RAM), которая доступна программам для использования. Когда мы определяем переменную, часть этой памяти отводится специально ей.
Наименьшая единица памяти — бит (с англ. binary digit), который может содержать либо значение 0, либо значение 1. 
Если просмотреть случайный кусочек памяти, то всё, что вы увидите, будет …011010100101010… или что-то в этом роде. Память организована в последовательные части — адреса. 
В современных компьютерах, у каждого бита по отдельности нет своего собственного адреса. Наименьшей единицей, которой дается адрес, является байт (состоит из 8 битов).

C++ поддерживает два основных способа инициализации переменных. 
1 - copy initialization (копирующая инициализация) с помощью знака равенства:
          int nValue = 5; // копирующая инициализация
2 - direct initialization (прямая инициализация) с помощью круглых скобок.
          int nValue(5); // прямая инициализация
3 - uniform initialization (новая форма инициализации, которая добавляется в C++ 11):
          int value{5};
          int value{}; // инициализация по умолчанию - 0

С++ самым правильным считается определять переменные как можно ближе к их первому использованию.

void
Void, как правило, используется в немногих случаях:
1. Чаще всего, как способ указать, что функция не возвращает значение
2. В языке C, как способ указать, что функция не принимает никаких параметров:
int getValue(void) // здесь void означает, что функция не принимает никакие параметры 
{
    int x;
    std::cin >> x;
    return x;
}
Значение void-а как «никаких параметров» является пережитком с языка C. Следующий код равнозначен и более предпочтителен в C++:
int getValue() // пустые скобки параметров функции - это то же самое, что и void
{
    int x;
    std::cin >> x;
    return x;
}
3. Related to pointers

Объем памяти, который использует переменная, основывается на ее типе данных. Так как мы, как правило, получаем доступ к памяти через имена переменных, а не через адреса памяти, то компилятор имеет возможность скрывать от нас все детали работы с переменными разных размеров.
Каждый раз, когда мы объявляем переменную, небольшая часть этой свободной памяти выделяется до тех пор, пока переменная существует. Поскольку современные компьютеры имеют много памяти, то в большинстве случаев – это не проблема, особенно когда в программе всего лишь несколько переменных. Тем не менее, для программ, которые требуют большого количества переменных (например, 100 000), разница между использованием 1-байтовых или 8-байтовых переменных может быть значительной.

1) boolean	
      bool	1 байт	
2) character	
      char	1 байт	
      wchar_t	1 байт	
      char16_t	2 байта
      char32_t	4 байта
3) integer	
      short	2 байта
      int	2 байта	
      long	4 байта	
      long long	8 байтов
4) floating point	
      float	4 байта	
      double	8 байтов	
      long double	8 байтов
     
1 байт signed	      от -128 до 127
1 байт unsigned	    от 0 до 255
2 байта signed	    от -32 768 до 32 767
2 байта unsigned	  от 0 до 65 535
4 байта signed	    от -2 147 483 648 до 2 147 483 647
4 байта unsigned	  от 0 до 4 294 967 295
8 байтов signed	    от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
8 байтов unsigned	  от 0 до 18 446 744 073 709 551 615

Набор целочисленных типов фиксированной величины (fixed-width integers) - приняты только в C++ 11
int8_t	  1 байт signed	      от -128 до 127
uint8_t	  1 байт unsigned	    от 0 до 255
int16_t	  2 байта signed	    от -32 768 до 32 767
uint16_t	2 байта unsigned	  от 0 до 65 535
int32_t	  4 байта signed	    от -2 147 483 648 до 2 147 483 647
uint32_t	4 байта unsigned	  от 0 до 4 294 967 295
int64_t	  8 байтов signed	    от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
uint64_t	8 байтов unsigned	  от 0 до 18 446 744 073 709 551 615


sizeof — это один из трех операторов в C++, который является словом, а не символом. 
Два другие оператора – это new и delete.     

Тип char — особый случай, он относится как целочисленному, так и к символьному типам данных.

char c;
short int si; // официально
short s;      // предпочтительнее
int i;
long int li; // официально
long l;      // предпочтительнее
long long int lli; // официально
long long ll;      // предпочтительнее


signed (со знаком) означает, что переменная может содержать как положительные (плюсовые), так и отрицательные (минусовые) числа.
Целочисленный тип unsigned (без знака) может содержать только положительные значения. 
Все целочисленные типы, кроме char, являются signed по умолчанию. Char же может быть как со знаком, так и без него (но, обычно, signed).


Что произойдет, если мы попытаемся использовать значение, которое выходит за рамки диапазона определенного типа данных? Ответ: переполнение. Переполнение (overflow) означает потерю битов, так как переменной не было выделено достаточно памяти для их хранения.

число 21 занимает 5 битов (10101). 4 крайние правые биты (0101) перейдут в переменную, а крайний левый бит (1) просто потеряется. Тогда наша переменная станет 0101, что равно 101 (нуль спереди не считается), а это уже число 5, а не 21.

#include <iostream>
 
int main()
{
    unsigned short x = 65535; // наибольшее значение, которое может хранить 16-битовая unsigned переменная
    std::cout << "x was: " << x << std::endl;       // выведет x was: 65535
    x = x + 1; // 65536 - это число уже не в диапазоне, произойдет переполнение, так как x не может хранить 17 битов
    std::cout << "x is now: " << x << std::endl;    // выведет x is now: 0
    return 0;
}

Экспоненциальная запись
Числа в экспоненциальной записи имеют следующий вид: мантисса х 10экспонент. Например, рассмотрим выражение 1.2 x 104. Значение 1.2 – это мантисса (значащая часть), а 4 – это экспонент (порядок числа). Результат этого выражения: 12 000.

В C++ буква «е» или «Е» означает, все равно что «поднести число 10 к степени…». Например, 1.2 x 104 — эквивалентно 1.2e4 или 5.9736 x 1024 можно записать как 5.9736e24.
Для чисел, меньших единицы, экспонент может быть отрицательным. Например, 5e-2 эквивалентно 5 * 10-2, что в свою очередь 5 / 102 или 0,05.

На самом деле, мы можем использовать экспоненциальную запись для присвоения значений переменным типа с плавающей запятой.
double d1(5000.0);
double d2(5e3); // другой способ присвоить значение 5000
 
double d3(0.05);
double d4(5e-2); // другой способ присвоить значение 0.05

Самое главное, что нужно понять: цифры в мантиссе (части перед E) называются значащие цифры. Количество значащих цифр определяет точность самого числа. Чем больше цифр в мантиссе, тем точнее число.

Есть две специальные категории чисел типа с плавающей запятой. Первая — Inf, что значит infinity (бесконечность). Inf может быть положительной или отрицательной. Вторая — NaN, что значит “Not a Number” (не число).
INF означает бесконечность, а IND – неопределенность (indeterminate).

char
Для конвертации между основными типами данных (например, из char в int или наоборот) используется static cast.

Newline (\n) против std::endl. Что использовать?
-  используйте std::endl, когда нужно, чтобы ваши данные выводились немедленно (например: при написании записи в файл или при обновлении индикатора процесса). Обратите внимание, что этот вариант может повлечь незначительное снижение производительности, особенно если запись на устройство происходит медленно (например, запись файла на диск).
-  используйте ‘\n’ в остальных случаях.

Символы всегда помещаются в одинарные кавычки.
Текст, который находится в двойных кавычках, называется string (например, “Hello, world!”). string (строка) – это набор последовательных символов.

В C++ есть два вида констант: литеральные и символьные (символические). 
Литеральные константы (обычно просто литералы) – это значения, которые вставляются непосредственно в код. 
Символьная (или еще символическая) константа – это тот же литерал (магическое число), только с идентификатором. 

const double gravity { 9.8 }; // предпочтительнее использовать const перед типом данных
int const sidesInSquare { 4 }; // ок, но не предпочтительно


const является наиболее полезным (и наиболее часто используемым) с параметрами функций:
void printInteger(const int myValue)
{
    std::cout << myValue;
}
Таким образом, при вызове функции, константа-параметр говорит нам, что функция не будет изменять значение переменной myValue. Во-вторых, она гарантирует, что функция не изменит значение myValue.
--------------------
compile time
Когда вы находитесь в процессе компиляции программы – это compile time (время компиляции). Компилятор проверяет вашу программу на синтаксические ошибки, затем конвертирует код в объектные файлы.

runtime
Когда вы находитесь в процессе запуска вашей программы или когда программа уже выполняется — это runtime (время выполнения). Код выполняется строка за строкой.
--------------------

В C++ есть два вида констант.
Константы runtime. Их значения определяются только во время выполнения (когда программа запущена). 
Константы compile-time. Их значения определяются во время компиляции. Например, сила тяжести Земли – это константа compile-time, мы её определили сами в ходе написания программы.

ключевое слово constexpr гарантирует, что тип константы — compile-time.
Не используйте #define для создания символьных констант.

#ifndef CONSTANTS_H
#define CONSTANTS_H
 
// определите собственное пространство имен для хранения констант
namespace constants
{
    const double pi(3.14159);
    const double avogadro(6.0221413e23);
    const double my_gravity(9.2); 
    // ... другие константы 
}
#endif

Используйте оператор разрешения области видимости (::) для доступа к константам в файлах .cpp:
#include "constants.h"
double circumference = 2 * radius * constants::pi;

Почему символьные константы лучше литеральных (магических чисел)? Почему использование const лучше директив #define?
Ответ 1
Использование литеральных констант (магических чисел) не только усложняет программу, но и затрудняет внесение изменений. Символьные константы лучше тем, что они предоставляют контекст того, зачем они и для чего, также если понадобится внести изменения — достаточно будет внести правки только в объявлении константы, а не рыскать по всему коду. Константы #define не отображаются в отладчике, вероятность конфликта имен у них выше.

------------------------------------------------------------------------------------------------------------
------------------------------------ Операторы в C++ ------------------------------------
------------------------------------------------------------------------------------------------------------

--------------- Перевод чисел из двоичной системы в десятичную и наоборот

десятичное число 5623:
5623 = (5 * 1000) + (6 * 100) + (2 * 10) + (3 * 1)
(5 * 10^3) + (6 * 10^2) + (2 * 10^1) + (3 * 1)

двоичные числа пишутся группами (в каждой по 4 цифры). Например: 1101 0101
двоичное число: 0101 1110
0101 1110 = (0 * 128) + (1 * 64) + (0 * 32) + (1 * 16) + (1 * 8) + (1 * 4 ) + (1 * 2) + (0 * 1). 
64 + 16 + 8 + 4 + 2 = 94.
0101 1110 (бинарное) = 94 (десятичное)

Перевод чисел из десятичной системы в двоичную. Способ №1
Первый заключается в непрерывном делении числа на 2 и записывании остатков. Если остаток (r) есть, то пишем 1, если нет – 0. Затем, читая их снизу вверх, мы получим готовое бинарное число.
Конвертация 148 из десятичной системы в двоичную:

148 / 2 = 74 r0
74 / 2 = 37 r0
37 / 2 = 18 r1
18 / 2 = 9 r0
9 / 2 = 4 r1
4 / 2 = 2 r0
2 / 2 = 1 r0
1 / 2 = 0 r1
148 в десятичной системе = 1001 0100 в двоичной.
Вы можете проверить этот ответ путем конвертации двоичного числа обратно в десятичную систему:
(1 * 128) + (0 * 64) + (0 * 32) + (1 * 16) + (0 * 8) + (1 * 4) + (0 * 2) + (0 * 1) = 148.

--------------- Сложение двоичных чисел
0110 (6 в десятичной системе) +
0111 (7 в десятичной системе) =
1101

13 = 1101.
В примерах выше мы работали только с целыми числами unsigned, которые могут быть только положительными. 
Сейчас же мы рассмотрим то, как работать с числами signed, которые могут быть и отрицательными.

С целыми числами signed используется метод two’s complement. Он означает, что самый левый (самый главный) бит используется в качестве знакового бита. Если значение знакового бита — 0, то число положительное, если 1, то число отрицательное.

Конвертация -5 в двоичную систему:
Сначала выясняем бинарное представление 5: 0000 0101
Затем инвертируем все биты (преобразуем в противоположные): 1111 1010
Затем добавляем 1: 1111 1011

--------------- Побитовые операторы
Побитовые операторы манипулируют отдельными битами в пределах переменной.
В прошлом, компьютерной памяти было очень мало и ею сильно дорожили. Это было стимулом максимально разумно использовать каждый доступный бит.
Теперь памяти существенно больше и программисты обнаружили, что лучше писать код так, чтобы было проще и понятнее его поддерживать, нежели усложнять ради незначительной экономии. Поэтому спрос на использование побитовых операторов несколько спал, за исключением случаев, когда необходима ну уже максимальная оптимизация (например: научные программы, которые используют огромное количество данных, игры, где манипуляции с битами могут быть использованы для дополнительной скорости, или встроенные программы, где память по-прежнему ограничена).

Побитовый сдвиг влево	            x << y	Все биты в x смещаются влево на y бит
Побитовый сдвиг вправо            x >> y	Все биты в x смещаются вправо на y бит
Побитовое НЕ	            	      ~x	    Все биты в x меняются на противоположные
Побитовое И	              	      x & y	  Каждый бит в x И каждый бит в y
Побитовое ИЛИ	            	      x | y	  Каждый бит в x ИЛИ каждый бит в y
Побитовое исключающее ИЛИ (XOR)		x ^ y	  Каждый бит в x XOR каждый бит в y

в выражении 3 << 1 мы имеем в виду «сдвинуть влево на одно место биты литерала 3».
Рассмотрим число 3, что в двоичной системе = 0011:
3 = 0011
3 << 1 = 0110 = 6
3 << 2 = 1100 = 12
3 << 3 = 1000 = 8   //один бит перемещается за пределы самого литерала! Биты, сдвинутые за пределы двоичного числа, теряются навсегда.
Сейчас, в большинстве случаев, оператор побитового сдвига влево используется для вывода данных.
x = x << 1;     // оператор << используется для побитового сдвига влево
std::cout << x; // оператор << используется для вывода данных в консоль
    
Оператор побитового сдвига вправо (>>) сдвигает биты вправо.
12 = 1100
12 >> 1 = 0110 = 6
12 >> 2 = 0011 = 3
12 >> 3 = 0001 = 1

Побитовое НЕ
Предположим, размер типа данных — 4 бита:
4 = 0100
~ 4 = 1011 = 11 (в десятичной системе)

Предположим, 8 бит:
4 = 0000 0100
~ 4 = 1111 1011 = 251 (десятичное)

Побитовые И, ИЛИ и исключающее ИЛИ (XOR)
5 | 6 будет:
0 1 0 1 // 5
0 1 1 0 // 6        true|false -> true, false|true -> true, true|true -> true, false|false -> false 
-------
0 1 1 1 // 7
Результат — 0111 (7 в десятичной системе).

Рассмотрим выражение 5 & 6:
0 1 0 1 // 5
0 1 1 0 // 6
--------
0 1 0 0 // 4

XOR 
При обработке двух операндов, исключающее ИЛИ возвращает true (1), только если один и только один из операндов является истинным (1). Если таких нет или все операнды равны 1, то результатом будет false (0). 
Рассмотрим выражение 6 ^ 3:
0 1 1 0 // 6
0 0 1 1 // 3
-------
0 1 0 1 // 5


Побитовые операторы присваивания
Присваивание с побитовым сдвигом влево	                <<=	    x <<= y	    Сдвигаем x влево на y бит
Присваивание с побитовым сдвигом вправо	                >>=	    x >>= y	    Сдвигаем x вправо на y бит
Присваивание с побитовой операцией ИЛИ	                |=	    x |= y	    Присваивание x | y для x
Присваивание с побитовой операцией И	                  &=	    x &= y	    Присваивание x & y для x
Присваивание с побитовой операцией исключающего ИЛИ	    ^=	    x ^= y	    Присваивание x ^ y для x

Например, вместо х = х << 1; вы можете записать х << = 1;.

--------------- Битовые флаги
// Определяем 8 отдельных битовых флагов (они могут представлять всё, что вы захотите)
// Обратите внимание: в C++11 лучше использовать "uint8_t" вместо "unsigned char"
const unsigned char option1 = 0x01; // шестнадцатеричный литерал для 0000 0001
const unsigned char option2 = 0x02; // шестнадцатеричный литерал для 0000 0010
const unsigned char option3 = 0x04; // шестнадцатеричный литерал для 0000 0100
const unsigned char option4 = 0x08; // шестнадцатеричный литерал для 0000 1000
const unsigned char option5 = 0x10; // шестнадцатеричный литерал для 0001 0000
const unsigned char option6 = 0x20; // шестнадцатеричный литерал для 0010 0000
const unsigned char option7 = 0x40; // шестнадцатеричный литерал для 0100 0000
const unsigned char option8 = 0x80; // шестнадцатеричный литерал для 1000 0000
 
// байтовое значения для хранения комбинаций с 8 возможных вариантов
unsigned char myflags = 0; // все флаги/параметры отключены до старта

В стандартной библиотеке C++ есть фича под названием std::bitset, которая упрощает работу с битовыми флагами.
Включение, выключение, переключение или запрашивание сразу нескольких битов можно осуществить в одной битовой операции. Когда мы соединяем отдельные биты вместе, в целях их модификации как группы, то это называется битовая маска.


------------------------------------------------------------------------------------------------------------
------------------------------------ Область видимости и другие типы переменных в C++ ------------------------------------
------------------------------------------------------------------------------------------------------------

--------------- Урок 47. Блоки стейтментов. Составные операторы
Практически, ограничений на количества вложенных блоков нет. Однако, не рекомендуется делать больше 3 ступеней вложенности (максимум 4). Если ваша функция нуждается в большем количестве вложенности, то эту функцию лучше разбить на несколько меньших функций!

int add(int x, int y)
{ // начало блока
    return x + y;
} // конец блока


--------------- Урок 48. Локальные переменные, область видимости и время жизни
Область видимости определяет, где можно использовать переменную. 
Время жизни (продолжительность) определяет, где она создается и уничтожается. 
Переменные, определенные внутри блока, называются локальными переменными. Локальные переменные имеют автоматическую продолжительность: они создаются (и инициализируются, если необходимо) в точке определения и уничтожаются при выходе из блока. 
Переменные, определенные во внешнем блоке, могут быть видны внутри вложенного блока.

--------------- Урок 49. Глобальные переменные
Глобальные переменные имеют файловую область видимости (или неформально “глобальную”), то есть их можно использовать в любом месте файла, в котором они объявлены.
Обычно глобальные переменные объявляют в верхней части кода, ниже директив #include, но выше любого другого кода.
Еще многие разработчики добавляют к глобальным переменным префикс g_ (“g” = “global”).

Если вы хотите сделать глобальную переменную внутренней (которую можно использовать только внутри одного файла) – используйте ключевое слово static.
Аналогично, если вы хотите сделать глобальную переменную внешней (которую можно использовать в любом файле программы) – используйте ключевое слово extern.
В уроке о работе с несколькими файлами мы разобрались, что для использования функций, которые объявлены в другом файле, нужно использовать предварительные объявления. Аналогично, для использования внешней глобальной переменной, которая была объявлена в другом файле, нужно использовать предварительное объявление переменной. Оно осуществляется через ключевое слово extern (без инициализируемого значения).
Функции имеют такие же свойства связи, что и переменные. По умолчанию они внешние, но можно сменить на внутренние с помощью ключевого слова static.


--------------- Урок 50. Почему глобальные переменные – зло?
--------------- Урок 51. Статические переменные
Так же, как мы используем префикс «g_» с глобальными переменными, префикс «s_» принято использовать со статическими переменными.

void incrementAndPrint()
{
    int value = 1; // автоматическая продолжительность по умолчанию
    ++value;
    std::cout << value << std::endl;
} // переменная value уничтожается здесь

void incrementAndPrint()
{
    static int s_value = 1; // переменная s_value - статическая. Эта строка выполняется только один раз.
    ++s_value;
    std::cout << s_value << std::endl;
} // переменная s_value не уничтожается здесь, но становится недоступной

--------------- Урок 52. Связи, область видимости и продолжительность
Область видимости идентификатора определяет, где он доступен.
Продолжительность переменной определяет, где она создается и где уничтожается.
Связь переменной определяет, относятся ли несколько упоминаний одного идентификатора к одной и той же переменной или нет.

--------------- Урок 53. Пространства имен
Пространство имен определяет область кода, в которой гарантируется уникальность всех идентификаторов. По умолчанию глобальные переменные и обычные функции определены в глобальном пространстве имен.
Чтобы избежать ситуаций, когда два независимых фрагмента кода имеют имена, которые конфликтуют друг с другом при совместном использовании, C++ позволяет объявлять собственные пространства имен через ключевое слово namespace. Всё, что объявлено внутри пользовательского пространства имен, принадлежит только этому пространству имен, а не глобальному.

add.h:
namespace DoMath
{
    // функция add() - это часть пространства имен DoMath
    int add(int x, int y)
    {
        return x + y;
    }
}

subtract.h:
namespace DoMath
{
    // функция subtract() - это также часть пространства имен DoMath
    int subtract(int x, int y)
    {
        return x - y;
    }
}

main.cpp:
#include "add.h" // импортируем DoMath::add()
#include "subtract.h" // импортируем DoMath::subtract()
int main(void)
{
    std::cout << DoMath::add(5, 4) << '\n';
    std::cout << DoMath::subtract(5, 4) << '\n';
 
    return 0;
}


--------------- Урок 54. Using statements
Если вы часто используете стандартную библиотеку языка C++, то постоянное добавление префикса «std::» может быть довольно утомительным, не правда ли? C++ предоставляет некие альтернативы упрощения, так называемые «using statements».

#include <iostream>
int main()
{
   using std::cout; // этот using declaration сообщает компилятору, что cout следует обрабатывать как std::cout
   cout << "Hello, world!"; // и никакого префикса std:: здесь уже не надо!
   return 0;
}


--------------- Урок 55. Неявное преобразование типов данных
Процесс преобразования значения из одного типа данных в другой называется преобразованием типа. Они могут выполняться во многих случаях:
1) Присваивание или инициализация переменной значением другого типа данных:
double k(4); // инициализация переменной типа double целочисленным значением 4
k = 7; // присваиваем переменной типа double целое число 7
2) Возвращение значения из функции, где тип возвращаемого значения другой:
float doSomething()
{
    return 4.0; // передача значения типа double 4.0 в функцию, которая возвращает float
}
3) Использование бинарного оператора с операндами разных типов:
double division = 5.0 / 4; // деление между значениями типов double и int

Существует два основных способа преобразования: 
- неявное преобразование типов, когда компилятор автоматически конвертирует один фундаментальный тип данных в другой и 
- явное преобразование типов,   когда разработчик использует оператор cast для управления конвертацией.

Есть два основных типа неявного преобразования: расширение и конверсия.

--------------- Урок 56. Явное преобразование типов данных (операторы casts)
В C++ есть 5 различных типов cast: 
- C-style cast,     // лучше избегать.   
        В программировании на языке C явное преобразование типов данных выполняется с помощью оператора () – 
        внутри пишем тип, в который нужно конвертировать. Например:
        int i1 = 11;
        int i2 = 3;
        float x = (float)i1 / i2;
- static_cast, 
        char c = 97;
        std::cout << static_cast<int>(c) << std::endl; // в результате будет 97, а не 'a'
- const cast,       //следует избегать вообще, потому что они полезны только в редких случаях
- dynamic cast и    // относится к теме указатели и наследование
- reinterpret cast. // следует избегать вообще, потому что они полезны только в редких случаях


--------------- Урок 57. Введение в std::string
Строковые литералы (такие как «Hello, world!») помещаются между двойными кавычками.
Поскольку их часто используют в программах, большинство современных языков программирования имеют встроенный тип данных string. В C++ есть свой, но не как часть основного языка, а как часть стандартной библиотеки.

Чтобы иметь возможность использовать строки в C++, сначала нужно подключить заголовочный файл <string>. Как только это будет сделано, мы сможем определять переменные типа std::string.

#include <string>
std::string name;
std::string name("Sasha"); // инициализируем переменную name строковым литералом "Sasha"

std::getline()
Чтобы извлечь полную строку ввода — лучше использовать функцию std::getline(). Она принимает два параметра: первый – std::cin, второй — переменная string.
    std::cout << "Enter your full name: ";
    std::string myName;
    std::getline(std::cin, myName); // считываем целую строку текста в переменную myName

Если вы вводите числовые значения, используя std::cin, не забывайте удалять символ новой строки с помощью std::cin.ignore().
std::cin.ignore(32767, '\n'); // удаляем символ новой строки из потока

Добавление строк
Вы можете использовать оператор +, чтобы объединить две строки, или оператор +=, чтобы добавить одну строку к другой.

Длина строк
    std::string myName("Sasha");
    std::cout << myName << " has " << myName.length() << " characters\n";
    

--------------- Урок 58. Перечисления (типы enum)
C++ позволяет программистам создавать свои собственные типы данных. Самый простой способ — с помощью перечислений. 
Перечисление (или перечисляемый тип) — это тип данных, где любое возможное значения (перечислитель) определяется как символьная константа. Объявить перечисление можно с помощью ключевого слова enum.

// Объявляем новое перечисление Colors
enum Colors
{
    // Ниже находятся перечислители
    // Это все возможные значения этого типа данных
    // Каждый перечислитель разделяется запятой, НЕ точкой с запятой
    COLOR_RED,
    COLOR_BROWN,
    COLOR_GRAY,
    COLOR_WHITE,
    COLOR_PINK,
    COLOR_ORANGE,
    COLOR_BLUE,
    COLOR_PURPLE, // о конечной запятой читайте ниже
}; // однако сам enum должен заканчиваться точкой с запятой 
// Определяем несколько переменных перечисляемого типа Colors
Colors paint = COLOR_RED;
Colors house(COLOR_GRAY);

Идентификаторы перечислений часто начинаются с заглавной буквы, а имена перечислителей вообще пишутся всеми заглавными. 
Распространено добавление префиксов к перечислителям, например, ANIMAL_ или COLOR_, как для предотвращения конфликтов имен, так и в целях комментирования кода.
Значения перечислителей
Каждому перечислителю автоматически присваивается целочисленное значение в зависимости от его позиции в списке перечисления. По умолчанию первому перечислителю присваивается целое значение 0, а каждому следующему — на 1 больше, чем предыдущему:

enum Colors
{
    COLOR_YELLOW, // присвоено 0
    COLOR_WHITE, // присвоено 1
    COLOR_ORANGE, // присвоено 2
    COLOR_GREEN, // присвоено 3
    COLOR_RED, // присвоено 4
    COLOR_GRAY, // присвоено 5
    COLOR_PURPLE, // присвоено 6
    COLOR_BROWN // присвоено 7
};
Colors paint(COLOR_RED);
std::cout << paint;

Можно и самому определять значения перечислителей. Они могут быть как положительными, так и отрицательными, или вообще иметь одинаковые значения с другими перечислителями. Любые не определенные вами перечислители будут иметь значения на 1 больше, чем предыдущие перечислители.

// определяем новый перечисляемый тип Animals
enum Animals
{
    ANIMAL_PIG = -4,
    ANIMAL_LION, // присвоено -3
    ANIMAL_CAT, // присвоено -2
    ANIMAL_HORSE = 6,
    ANIMAL_ZEBRA = 6, // имеет то же значение, что и ANIMAL_HORSE
    ANIMAL_COW // присвоено 7
};

Вывод перечислителей
Как вы уже могли наблюдать, попытка вывести перечисляемое значение с помощью std::cout приводит к выводу целочисленного значения самого перечислителя (т.е. порядкового номера). Но как вывести значение перечислителя в виде текста? Один из способов — написать функцию с использованием стейтментов if:

enum Colors
{
    COLOR_PURPLE, // присвоено 0
    COLOR_GRAY, // присвоено 1
    COLOR_BLUE, // присвоено 2
    COLOR_GREEN, // присвоено 3
    COLOR_BROWN, // присвоено 4
    COLOR_PINK, // присвоено 5
    COLOR_YELLOW, // присвоено 6
    COLOR_MAGENTA // присвоено 7
};
 
void printColor(Colors color)
{
    if (color == COLOR_PURPLE)
        std::cout << "Purple";
    else if (color == COLOR_GRAY)
        std::cout << "Gray";
    else if (color == COLOR_BLUE)
        std::cout << "Blue";
    else if (color == COLOR_GREEN)
        std::cout << "Green";
    else if (color == COLOR_BROWN)
        std::cout << "Brown";
    else if (color == COLOR_PINK)
        std::cout << "Pink";
    else if (color == COLOR_YELLOW)
        std::cout << "Yellow";
    else if (color == COLOR_MAGENTA)
        std::cout << "Magenta";
    else
        std::cout << "Who knows!";
}

Перечисляемые типы невероятно полезны для документации кода и улучшения читабельности.
int readFileContents()
{
    if (!openFile())
        return -1;
    if (!parseFile())
        return -2;
    if (!readFile())
        return -3;
 
    return 0; // если успешно
}
Однако магические числа, как в примере выше, не очень эффективное решение. Альтернатива — использовать перечисления:
enum ParseResult
{
    SUCCESS = 0,
    ERROR_OPENING_FILE = -1,
    ERROR_PARSING_FILE = -2,
    ERROR_READING_FILE = -3
};
 
ParseResult readFileContents()
{
    if (!openFile())
        return ERROR_OPENING_FILE;
    if (!parseFile())
        return ERROR_PARSING_FILE;
    if (!readfile())
        return ERROR_READING_FILE;
 
    return SUCCESS; //если успешно
}


--------------- Урок 59. Классы enum
в C++ 11 появляется новое понятие — класс enum (или перечисление с областью видимости), который добавляет перечислению, как вы уже могли понять, локальную область видимости с её правилами и строгие правила типов. Для создания такого класса нужно просто добавить ключевое слово class сразу после enum. 


--------------- Урок 60. Псевдонимы типов. Typedef и type alias
Typedef позволяет программисту создать псевдоним для любого типа данных и использовать его вместо фактического имени типа. Чтобы объявить typedef (псевдоним типа) — используйте ключевое слово typedef, дальше тип данных, для которого создается псевдоним, а дальше сам псевдоним:

typedef double time_t; // определяем time_t как псевдоним типа double
// Следующие два стейтменты эквивалентны:
double howMuch;
time_t howMuch;

Обычно, к псевдонимам typedef добавляют окончание «_t». 
Typedef не определяет новый тип. Это просто псевдоним (другое имя) для уже существующего типа. 

Первое использование typedef — улучшение документации и разборчивости кода. Имена типов, такие как char, int, long, double и bool хороши для описания того, какой тип возвращает функция, но чаще всего мы хотим знать, для какой цели служит возвращаемое значение.
Typedef также позволяет изменить базовый тип объекта без внесения изменений в большое количество кода. 
Еще одним большим преимуществом typedef является возможность скрывать специфические, для определенных платформ (операционных систем), детали. (Кроссплатформенность)
С помощью typedef вы можете давать простые имена сложным типам данных, например:
typedef std::vector<std::pair<std::string, int> > pairlist_t;

в C++ 11 ввели новый улучшенный синтаксис для typedef, который имитирует способ объявления переменных. Этот синтаксис называется type alias (тип псевдонима). 

Следующий typedef:
typedef double time_t; // используем time_t как псевдоним типа double
В С++ 11 можно объявить как:
using time_t = double; // используем time_t как псевдоним типа double

Обратите внимание, что хоть мы используем ключевое слово «using», оно не имеет ничего общего со стейтментами using, связанными с пространствами имен. Это ключевое слово имеет несколько значений, в зависимости от контекста.


--------------- Урок 61. Структуры
Структура (struct) позволяет группировать переменные разных типов в единое целое.
Вместо 
std::string myName;
int myBirthDay;
int myBirthMonth;
int myBirthYear;
int myHeight;
int myWeight;

Используем структуру
// Объявление и определение структур
struct Employee
{
    short id;
    int age;
    double salary;
};

Мы определили структуру с именем Employee. Она содержит 3 переменные: id типа short, age типа int и salary типа double. Эти переменные, которые являются частью структуры, называются членами (или полями). 
Одна из самых простых ошибок в C++ — забыть точку с запятой в конце объявления структуры. 

Чтобы использовать структуру Employee, мы просто объявим переменную типа Employee:
Employee john; // имя структуры Employee начинается с большой буквы, а переменная john с маленькой
Employee james; // создаем структуру Employee для James
Oпределение переменной структуры приведет к выделению памяти под неё.

Доступ к членам структур
Когда мы определяем переменную, такую как Employee john, то john ссылается на всю структуру. Для того, чтобы получить доступ к отдельным элементам-полям, используется оператор выбора члена (точка). Ниже приведен пример использования оператора выбора членов для инициализации каждого поля структуры:

Employee john; // создаем структуру Employee для John
john.id = 8; // присваиваем значение полю id внутри структуры john
john.age = 27; // присваиваем значение полю age внутри структуры john
john.salary = 32.17; // присваиваем значение полю salary внутри структуры john

Инициализация структур
Инициализация структур путем присваивания значений каждому члену по порядку – занятие довольно громоздкое (особенно, если этих членов много), поэтому в C++ есть более быстрый способ инициализации структур — список инициализаторов.

Employee john = { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
Employee james = { 6, 29}; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)

В C++ 11 можно также использовать инициализацию uniform:
Employee john { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
Employee james { 6, 29 }; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)

Вложенные структуры
Одни структуры могут содержать другие структуры.

struct Employee
{
    short id;
    int age;
    double salary;
};
 
struct Company
{
    Employee CEO; // Employee - это структура внутри структуры Company 
    int numberOfEmployees;
};
 
Company myCompany;
// Company myCompany = {{ 3, 35, 55000.0f }, 7 };



--------------- Урок 62. Ключевое слово auto. Вывод типов
Ключевое слово auto использовалось для явного указания, что переменная должна иметь автоматическую продолжительность.
В C++ 14 функциональность ключевого слова auto была расширена для автоматического определения типа возвращаемого значения функции. 
auto subtract(int a, int b)
{
    return a - b;
}

int subtract(int a, int b);
В C++ 11 это можно записать как:
auto subtract(int a, int b) -> int;


------------------------------------------------------------------------------------------------------------
------------------------------------ Порядок выполнения кода в программе. Циклы, ветвления в C++ ------------------------------------
------------------------------------------------------------------------------------------------------------

--------------- Урок 63. Порядок выполнения программ. Операторы управления
В C++ есть операторы управления порядком выполнения, которые позволяют программисту изменить порядок выполнения программы центральным процессором.
1) Остановка (halt)
Самый простой оператор управления порядком выполнения — это остановка, которая сообщает программе немедленно прекратить выполнение. В C++ остановка осуществляется через использование функции exit(), которая определена в заголовке cstdlib. Функция exit() принимает целочисленный параметр, который возвращает обратно в операционную систему как код выхода.
#include <cstdlib> // нужно для функции exit()
#include <iostream>
int main()
{
    std::cout << 5;
    exit(0); // завершает выполнение программы и возвращает операционной системе 0 
 
    // Следующие стейтменты никогда не выполняться
    std::cout << 3;
    return 0;
}
2) Прыжок (jump)
Следующим оператором управления порядком выполнения является прыжок (или переход). Он безоговорочно сообщает компилятору во время выполнения перейти из одного стейтмента к другому – сделать прыжок. 
Ключевые слова goto, break и continue являются разными типами прыжков.
3) Условные ветвления
Условное ветвление заставляет программу изменить свой порядок выполнения, основываясь на значении результата выражения. Одним из основных операторов условного ветвления является if, который вы уже могли видеть в программах раньше.
Ключевое слово switch также предоставляет механизм для выполнения условного ветвления.
4) Циклы
Цикл заставляет программу многократно выполнять определенное количество стейтментов до тех пор, пока определенное условие не станет ложным.
В C++ есть 3 типа циклов: while, do while и for. C++ 11 добавила поддержку еще одного типа циклов — for each. 
5) Исключения
Исключения предлагают механизм обработки ошибок, возникающих в функции. Если в функции возникает ошибка, с которой она не может справиться, то она может выполнить исключение. Это заставит ЦП перейти к ближайшему блоку кода, который обрабатывает исключения этого типа.



--------------- Урок 64. Операторы условного ветвления if и else
Стейтменты null
Также в C++ можно не указывать основную часть оператора if. Такие стейтменты называются нулевыми (или стейтменты null), объявить их можно, используя точку с запятой вместо выполняемой операции.

if (a > 15)
    ; // это стейтмент null
    
    
--------------- Урок 65. Оператор switch

--------------- Урок 66. Оператор goto
#include <iostream>
#include <cmath> // для функции sqrt() 
 
int main()
{
    double z;
tryAgain: // это statement label
    std::cout << "Enter a non-negative number"; 
    std::cin >> z;
 
    if (z < 0.0)
        goto tryAgain; // а это оператор goto 
 
    std::cout << "The sqrt of " << z << " is " << sqrt(z) << std::endl;
    return 0;
}

В целом, программисты избегают использования оператора goto в C++ (и в большинстве других высокоуровневых языков). Основная проблема с ним заключается в том, что он позволяет программисту управлять выполнением кода так, что точка выполнения может прыгать по коду произвольно. А это в свою очередь создает то, что бывалые программисты называют «спагетти-код». Спагетти-код — это код, порядок выполнения которого напоминает тарелку со спагетти (всё запутано и закручено), что крайне затрудняет следованию и пониманию логике выполнения такого кода.

--------------- Урок 67. Цикл while
С другой стороны, если условие цикла всегда принимает значение true, то и сам цикл будет выполняться вечно. Это называется бесконечный цикл. 

Мы можем преднамеренно объявить бесконечный цикл следующим образом:
while (1) // или while (true)
{
  // этот цикл будет выполняться бесконечно 
}

Единственный способ выйти из бесконечного цикла – использовать операторы return, break, exit, goto или выполнение исключения.


--------------- Урок 68. Цикл do while
Одна интересная вещь в цикле while заключается в том, что если условие цикла изначально false, то тело цикла не будет выполняться вообще. Но иногда бывают случаи, когда нужно, чтобы цикл выполнился хотя бы один раз, например, при отображении меню. Для решения этой проблемы C++ предлагает цикл do while.

--------------- Урок 69. Цикл for
Безусловно, наиболее используемым циклом в C++ является for. Цикл for идеален, когда мы точно знаем, сколько итераций должно быть.

Одна из самых больших проблем, с которой приходится сталкиваться начинающим программистам в циклах for (а также и в других типах циклов) — это ошибка на единицу (или ошибка неучтенной единицы). Она возникает, когда цикл повторяется на 1 раз больше или на 1 раз меньше нужного количества итераций. Это обычно происходит из-за того, что в условии используется некорректный оператор сравнения (например, > вместо >=).

Также в циклах можно пропускать одно или все сразу выражения. Например:
int count=0;
for ( ; count < 10; )
{
    cout << count << " ";
    ++count;
}

Результат:
0 1 2 3 4 5 6 7 8 9

В операторе for можно вообще ничего не указывать. Подобное приведет к бесконечному выполнению цикла:
for (;;)
    тело цикла;

Пример выше эквивалентен:
while (true)
    тело цикла;

Несколько объявлений переменных в цикле for
for (int aaa=0, bbb=9; aaa < 10; ++aaa, --bbb)
        cout << aaa << " " << bbb << endl;
        


--------------- Урок 70. Операторы break и continue
В контексте оператора switch break обычно используется в конце каждого кейса для его завершения (что предотвращает fall-through)
В контексте циклов оператор break используется для завершения работы цикла раньше времени.
Oператор break может использоваться и для выхода из бесконечного цикла.

Оператор break завершает работу switch-а или цикла, и выполнение кода продолжается с первого стейтмента, который находится сразу после этого же switch-а или цикла. 
Оператор return завершает выполнение всей функции, в которой находится цикл, и выполнение продолжается в точке, где была вызвана эта функция.

Оператор continue позволяет сразу перейти в конец тела цикла, пропуская весь код, который находится под ним.


--------------- Урок 71. Генерация случайных чисел. Функции srand() и rand()

--------------- Урок 72. Обработка некорректного ввода через std::cin
std::cin.ignore(32767, '\n');  // удаляем до 32767 символов из входного буфера вплоть до появления символа '\n' (который мы также удаляем)

if (std::cin.fail()) // если предыдущее извлечение было провальным
{
    std::cin.clear(); // возвращаем cin в 'обычный' режим работы
    std::cin.ignore(32767,'\n'); // и удаляем значения предыдущего ввода из входного буфера
}


--------------- Урок 73. Введение в тестирование кода


------------------------------------------------------------------------------------------------------------
------------------------------------ Массивы, Строки, Указатели и Ссылки в C++ ------------------------------------
------------------------------------------------------------------------------------------------------------

--------------- Урок 74. Массивы. Часть 1
Массивам фиксированного размера память выделяется во время компиляции.
C++ поддерживает еще один тип массивов, известный как динамический массив. Размер такого массива может быть установлен ​​во время выполнения программы и его можно изменить. 


--------------- Урок 75. Массивы. Часть 2
C++ поддерживает более удобный способ инициализации целых массивов с помощью списка инициализаторов. 
int array[5] = { 4, 5, 8, 9, 12 }; // используется список инициализаторов для инициализации фиксированного массива

Чтобы инициализировать все элементы массива значением 0, нужно:
// Инициализируем все элементы массива значением 0
int array[5] = { };
В C++ 11 вместо этого может использоваться синтаксис uniform инициализации:
int array[5] { 4, 5, 8, 9, 12 };

int array[5] = { 0, 1, 2, 3, 4 }; // явно указываем длину массива
int array[] = { 0, 1, 2, 3, 4 }; // список инициализаторов автоматически задает длину массива



--------------- Урок 76. Массивы и циклы

--------------- Урок 77. Сортировка массивов методом выбора
Чтобы поменять два элемента местами, мы можем использовать функцию std::swap() из стандартной библиотеки C++, которая определена в заголовочном файле <algorithm>

Способы сортировки массивов: 
 - Сортировка методом выбора, (простая но медленная)
        1. Начиная с элемента под индексом 0, ищем в массиве наименьшее значение.
        2. Найденное значение меняем местами с нулевым элементом.
        3. Повторяем шаги 1 и 2 уже для следующего индекса в массиве.
 - std::sort. Она находится в заголовке <algorithm> 
 - «сортировка пузырьком». Пузырьковая сортировка работает, сравнивая смежные пары элементов и меняя их местами, если удовлетворяются определенные критерии. И таким образом элементы «скачут пузырьком» до конца массива.
 
 

--------------- Урок 78. Многомерные массивы
Массив массивов называется многомерным массивом.

int array[2][4];    // двумерный массив
В двумерном массиве первый (левый) индекс принято читать как количество строк, а второй (правый) как количество столбцов.
[0][0]  [0][1]  [0][2]  [0][3]  // строка 0
[1][0]  [1][1]  [1][2]  [1][3]  // строка 1

Инициализация двумерных массивов
int array[3][5] =
{
{ 1, 2, 3, 4, 5 }, // строка 0
{ 6, 7, 8, 9, 10 }, // строка 1
{ 11, 12, 13, 14, 15 } // строка 2
};

Для доступа ко всем элементам двумерного массива требуется два цикла: один для строк и один для столбцов. Поскольку доступ к двумерным массивам обычно выполняется по строкам, то левый индекс используется в качестве внешнего цикла.
for (int row = 0; row < numRows; ++row) // доступ по строкам
    for (int col = 0; col < numCols; ++col) // доступ к каждому элементу в строке
        std::cout << array[row][col];


--------------- Урок 79. Строки C-style
Современный C++ поддерживает два разных типа строк: 
1) std::string (как часть стандартной библиотеки) и 
2) строки C-style (изначально унаследованные от языка C).     
    char mystring[] = "string";
    Строка C-style — это простой массив символов, который использует нуль-терминатор. 
    Нуль-терминатор — это специальный символ (‘\0’, код ASCII — 0), используемый для обозначения конца строки.
Хотя «string» имеет только 6 букв, C++ автоматически добавляет нуль-терминатор в конец строки. 
Следовательно, длина массива mystring на самом деле 7!

Обратите внимание, это нормально, если длина массива больше строки, которую он хранит:
char name[15] = "Max"; // используется только 4 символа (3 буквы + нуль-терминатор)

C++ предоставляет множество функций для управления строками C-style, которые находятся в составе библиотеки <cstring>
- strcpy() позволяет копировать содержимое одной строки в другую. 
- strlen() возвращает длину строки C-style (без нуль-терминатора).
- strcat() — добавляет одну строку к другой (опасно);
- strncat() — добавляет одну строку к другой (с проверкой размера места назначения);
- strcmp() — сравнивает две строки (возвращает 0, если они равны);
- strncmp() — сравнивает две строки до определенного количества символов (возвращает 0, если они равны).

!!! Используйте std::string вместо строк C-style.


--------------- Урок 80. Указатели. Введение
int a = 7;
std::cout << a << '\n'; // выводим значение переменной a                      // Output: 7
std::cout << &a << '\n'; // выводим адрес памяти переменной a                 // Output: 0046FCF0
std::cout << *&a << '\n'; /// выводим значение ячейки памяти переменной a     // Output: 7

Оператор адреса (address-of) & 
Хотя оператор адреса выглядит так же, как оператор побитового И, отличить их можно так: 
оператор адреса — унарный оператор, а 
оператор побитового И – бинарный.

Оператор разыменования (*) позволяет получить значение по определенному адресу:
Хотя оператор разыменования выглядит так же, как и оператор умножения, отличить их можно по тому, что 
оператор разыменования — унарный, а 
оператор умножения — бинарный.

Указатель — это переменная, значением которой является адрес памяти.
int *iPtr; // указатель на значение int
double *dPtr; // указатель на значение double
int* iPtr3; // также корректный синтаксис (допустимый, но не желателен)
int* iPtr3, iPtr4; // iPtr3 - это указатель на значение int, а iPtr4 - это обычная переменная типа int!
По этой причине при объявлении указателя мы рекомендуем указывать звездочку рядом с именем переменной.

int value = 5;
int *ptr = &value; // инициализируем ptr адресом значения переменной

Тип указателя должен соответствовать типу переменной, на которую он указывает:

Следующее не является допустимым:
int *ptr = 7;
Это связано с тем, что указатели могут содержать только адреса, а целочисленный литерал 7 не имеет адреса памяти. 

C++ также не позволит вам напрямую присваивать адреса памяти указателю:
double *dPtr = 0x0012FF7C; // не ок, рассматривается как присваивание целочисленного литерала

int value = 5;
std::cout << &value; // выводим адрес value           0034FD90
std::cout << value; // выводим содержимое value       5
 
int *ptr = &value; // ptr указывает на value
std::cout << ptr; // выводим адрес, который хранится в ptr, т.е. &value                 0034FD90
std::cout << *ptr; // разыменовываем ptr (получаем значение на которое указывает ptr)   5

Зачем использовать указатель, если мы можем использовать исходную переменную?
Однако, оказывается, что указатели полезны в следующих случаях:
1. Массивы реализованы с помощью указателей. Они могут использоваться для итерации по массиву (рассмотрим в следующих уроках).
2. Они являются единственным способом динамического распределения памяти в C++ (рассмотрим в следующих уроках). Это, безусловно, самый распространенный вариант использования указателей.
3. Они могут использоваться для передачи большого количества данных в функцию без копирования этих данных (рассмотрим в следующих уроках).
4. Они могут использоваться для передачи одной функции в качестве параметра другой функции.
5. Они используются для достижения полиморфизма при работе с наследованием (рассмотрим в следующих уроках).
6. Они могут использоваться для представления одной структуры/класса в другой структуре/классе, формируя, таким образом, целые цепочки.


--------------- Урок 81. Нулевые указатели
Помимо адресов памяти, есть еще одно значение, которое указатель может хранить: значение null. Нулевое значение (значение null) — это специальное значение, которое означает, что указатель ни на что не указывает. Указатель, содержащий значение null, называется нулевым указателем.

В C++ мы можем присвоить указателю нулевое значение, инициализируя его или присваивая ему литерал 0
int *ptr(0);  // ptr - теперь нулевой указатель 
int *ptr1; // ptr1 - неинициализирован
ptr1 = 0; // ptr1 - теперь нулевой указатель
Начиная с C++11, при работе с нулевыми указателями, использование nullptr является более предпочтительным вариантом, нежели использование 0
int *ptr = nullptr;


--------------- Урок 82. Указатели и массивы

--------------- Урок 83. Адресная арифметика и индексация массива
ptr + 1 — это адрес следующего целочисленного значения в памяти после ptr. 
ptr - 1 – это адрес предыдущего целочисленного значения (перед ptr).



--------------- Урок 84. Символьные константы строк C-style

--------------- Урок 85. Динамическое выделение памяти. Операторы new и delete
С++ поддерживает три основных типа выделения (распределения) памяти
1) Статическое выделение памяти выполняется для статических и глобальных переменных. Память выделяется один раз, при запуске программы, и сохраняется на протяжении работы всей программы.
2) Автоматическое выделение памяти выполняется для параметров функции и локальных переменных. Память выделяется при входе в блок, в котором находятся эти переменные, и освобождается при выходе из него.
3) Динамическое выделение памяти.

Память для большинства обычных переменных (включая фиксированные массивы) выделяется из специального резервуара памяти — стека.
Объем памяти стека в программе, как правило, невелик – в Visual Studio он по умолчанию равен 1МБ. Если вы превысите это число, то произойдет переполнение стека, и операционная система автоматически завершит выполнение вашей программы.
К счастью, эти проблемы легко устраняются с помощью динамического выделения памяти. Динамическое выделение памяти — это способ запроса памяти из операционной системы запущенными программами при необходимости. 
Эта память не выделяется из ограниченной памяти стека программы, а из гораздо большего хранилища, управляемого операционной системой — heap (кучи). На современных компьютерах размер кучи может составлять гигабайты памяти.

Для динамического выделения памяти для одной переменной используется оператор new:
new int; // динамически выделяем целочисленную переменную и сразу же отбрасываем результат (так как нигде его не сохраняем)
Оператор new возвращает указатель, содержащий адрес выделенной памяти.
Для доступа к выделенной памяти создается указатель:
int *ptr = new int; // динамически выделяем целочисленную переменную и присваиваем её адрес ptr, чтобы потом иметь возможность доступа к ней

Затем мы можем разыменовать указатель для получения значения:
*ptr = 8; // присваиваем значение 8 только что выделенной памяти

Когда вы динамически выделяете память, вы просите операционную систему зарезервировать часть этой памяти для использования вашей программой. Если ОС может выполнить этот запрос, то возвращается адрес этой памяти обратно, в ваше приложение. С этого момента и в дальнейшем ваше приложение может использовать эту память, как только пожелает. Когда вы уже выполнили всё, что было необходимо, с этой памятью, то её нужно вернуть обратно в операционную систему, для распределения между другими запросами.

Когда уже всё, что нужно было, выполнено с динамически выделенной переменной – нужно явно указать С++ освободить эту память. Для отдельных переменных это выполняется с помощью оператора delete:

// предположим, что ptr ранее уже был выделен с помощью оператора new
delete ptr; // возвращаем память, на которую указывал ptr, обратно в операционную систему
ptr = 0; // делаем ptr нулевым указателем (используйте nullptr вместо 0 в C++11)


Оператор delete на самом деле ничего не удаляет. Он просто возвращает память, которая была выделена ранее, обратно в операционную систему. Затем операционная система может переназначить эту память другому приложению (или этому же снова).
Хотя может показаться, что мы удаляем переменную, но это не так! Переменная-указатель по-прежнему имеет ту же область видимости, что и раньше, и ей можно присвоить новое значение, как и любой другой переменной.

Указатель, указывающий на освобожденную память, называется висячим указателем. 

Утечка памяти
Динамически выделенная память не имеет области видимости. То есть она остается выделенной до тех пор, пока не будет явно освобождена или пока ваша программа не завершится (и операционная система очистит все буфера памяти самостоятельно). 

Утечка памяти происходит, когда ваша программа теряет адрес некоторой динамически выделенной части памяти (например, переменной или массива), прежде чем вернуть её обратно в операционную систему. Когда это происходит, то программа уже не может удалить эту динамически выделенную память, поскольку она больше не знает, где та находится. Операционная система также не может использовать эту память, поскольку считается, что та по-прежнему используется вашей программой.

int value = 7;
int *ptr = new int; // выделяем память
ptr = &value; // старый адрес утерян - произойдет утечка памяти

Это легко решается удалением указателя перед операцией переприсваивания:
int value = 7;
int *ptr = new int; // выделяем память
delete ptr; // возвращаем память обратно в операционную систему
ptr = &value; // переприсваиваем указателю адрес value

Кроме того, утечка памяти также может произойти и через двойное выделение памяти:
int *ptr = new int;
ptr = new int; // старый адрес утерян - произойдет утечка памяти



--------------- Урок 86. Динамические массивы
Для выделения динамического массива используются формы операторов new и delete (а именно new[] и delete[])

Инициализация динамических массивов
int *array = new int[length]();

До C++11 не было простого способа инициализировать динамический массив ненулевыми значениями (список инициализаторов работал только с фиксированными массивами).
Однако, начиная с C++11, появилась возможность инициализации динамических массивов через списки инициализаторов!
int fixedArray[5] = { 9, 7, 5, 3, 1 }; // инициализируем фиксированный массив
int *array = new int[5] { 9, 7, 5, 3, 1 }; // инициализируем динамический массив

Динамическое выделение массивов позволяет задавать их длину во время выделения. Однако C++ не предоставляет встроенный способ изменения размера массива, который уже был выделен. Но и это ограничение можно обойти, динамически выделив новый массив, скопировав все элементы со старого массива, и удалив старый массив. Однако и этот способ подвержен ошибкам, особенно когда класс является типом элемента (об этом позже).
К счастью, в C++ есть массивы, размер которых можно изменять, и называются они векторами (std::vector), живут в стандартной библиотеки C++.

--------------- Урок 87. Указатели и const
До этого момента все указатели, которые вы видели, были неконстантными указателями на неконстантные значения.
Мы не можем присвоить неконстантному указателю константную переменную.

1) Указатель на константное значение — это указатель (неконстантный), который указывает на неизменное значение.
const int value = 7;
const int *ptr = &value; // здесь всё нормально, ptr - это неконстантный указатель, который указывает на "const int"
*ptr = 8; // нельзя, мы не можем изменить константное значение

2) Константный указатель — это указатель, значение которого не может быть изменено после инициализации.
    int value = 7;
    int *const ptr = &value;

3) Константные указатели на константные значения
    int value = 7;
    const int *const ptr = &value;

Rules:
- неконстантный указатель можно перенаправить указывать на любой другой адрес;
- с помощью указателя на неконстантное значение можно изменить это же значение (на которое он указывает);
- константный указатель всегда указывает на один и тот же адрес, и этот адрес не может быть изменен;
- указатель на константное значение обрабатывает значение как константное (даже если оно таковым не является) и, следовательно, это значение через указатель изменить нельзя.

int value = 7;
const int *ptr1 = &value;       // ptr1 указывает на "const int", поэтому это указатель на константное значение 
int *const ptr2 = &value;       // ptr2 указывает на "int", поэтому это константный указатель на неконстантное значение
const int *const ptr3 = &value; // ptr3 указывает на "const int", поэтому это константный указатель на константное значение


--------------- Урок 88. Ссылки
Типы переменных:
1) обычные переменные, которые хранят значения напрямую;
2) указатели, которые хранят адрес другого значения (или null), и для доступа к которым выполняется операция разыменования указателя.
3) Ссылки — это тип переменной в C++, который работает как псевдоним другого объекта или значения.

C++ поддерживает три типа ссылок:
1) ссылки на неконстантные значения (обычно их называют просто «ссылки» или «неконстантные ссылки»).
    объявляется с использованием амперсанда (&) между типом и именем ссылки
    int value = 7;      // обычная переменная
    int &ref = value;   // ссылка на переменную value. Инициализирована переменной value
    int &invalidRef;    // некорректная ссылка. Ссылка должна ссылаться на что-нибудь
    value = 8;          // value теперь 8
    ref = 9;            // value теперь 9
    В этом контексте амперсанд не означает «оператор адреса», он означает «ссылка на».
    
2) ссылки на константные значения (обычно их называют «константные ссылки»).
    const int value = 7;
    const int &ref = value; // ref - это ссылка на константную переменную value
    
3) в C++11 добавлены ссылки на r-value.

l-value — это объект, который имеет определенный адрес памяти (например, переменная x) и сохраняется за пределами одного выражения. 
r-value — это временное значение без определенного адреса памяти и с областью видимости выражения (т.е. сохраняется в пределах одного выражения). В качестве r-values могут быть как результаты выражения (например, 2 + 3), так и литералы.


Ссылки в качестве параметров в функциях
#include <iostream>
 
// ref - это ссылка на переданный аргумент, не копия аргумента
void changeN(int &ref)
{
	ref = 8;
}
 
int main()
{
	int x = 7;
 
	std::cout << x << '\n';     // результат 7
 
	changeN(x); // обратите внимание, этот аргумент не обязательно должен быть ссылкой
 
	std::cout << x << '\n';     // результат 8
	return 0;
}


Если определенное задание может быть решено с помощью как ссылок, так и указателей, то лучше использовать ссылки. Указатели следует использовать в ситуациях, только когда ссылки недостаточно эффективны (например, при динамическом выделении памяти).

--------------- Урок 89. Ссылки и const

--------------- Урок 90. Оператор доступа к членам через указатель

--------------- Урок 91. Цикл foreach
foreach (или «цикл, основанный на диапазоне»), который предоставляет более простой и безопасный способ итерации по массиву (или любой другой структуре типа списка).

for (объявление_элемента : массив)
   statement;
   
int main()
{
    int math[] = { 0, 1, 4, 5, 7, 8, 10, 12, 15, 17, 30, 41};
    for (int number : math) // итерация по массиву math
       std::cout << number << ' '; // получаем доступ к элементу массива в этой итерации через переменную number
 
    return 0;
}


Циклы foreach работают не только с фиксированными массивами, но также и со многими другими структурами типа списка, такими как векторы (например, std::vector), связанные списки, деревья.

int main()
{
    std::vector<int> math = { 0, 1, 4, 5, 7, 8, 10, 12, 15, 17, 30, 41}; // обратите внимание на использование std::vector здесь вместо фиксированного массива
    for (const auto &number : math)
        std::cout << number << ' ';
 
    return 0;
}

Циклы foreach не предоставляют прямой способ получения индекса текущего элемента массива.

Обратите внимание, поскольку циклы foreach были добавлены в C++11, они не будут работать на старых компиляторах (которые С++11 не поддерживают).

--------------- Урок 92. Указатели типа void
Указатель типа void — это указатель, который может указывать на объект любого типа данных, но он сам не знает, какой это будет тип. Для разыменования указатель типа void должен быть явно преобразован с помощью оператора cast в другой тип данных. 
Нулевой указатель — это указатель, который не указывает на адрес. Указатель void может быть нулевым указателем.

--------------- Урок 93. Указатели на указатели
Указатель на указатель – это именно то, что вы подумали: указатель, который содержит адрес другого указателя.
Указатель на указатель на int объявляется с использованием двух звёздочек:
int **ptrptr; // указатель на указатель на int, две звёздочки

int value = 7;
 
int *ptr = &value;
std::cout << *ptr; // разыменовываем указатель, чтобы получить значение int
 
int **ptrptr = &ptr;
std::cout << **ptrptr; // первое разыменование, чтобы получить указатель на int, второе разыменование, чтобы получить значение int


--------------- Урок 94. Введение в std::array
У фиксированных и динамических массивах есть недостатки: 
- фиксированные массивы распадаются в указатели, теряя информацию о своей длине, 
- в динамических массивах проблемы могут возникнуть с освобождением памяти и с попытками изменить размер.
Поэтому, в стандартную библиотеку C++ добавили функциональности, которые упрощают процесс управления массивами: std::array и std::vector.

1) std::array — это фиксированный массив, который не распадается в указатель при передаче в функцию.

#include <array>
std::array<int, 4> myarray; // объявляем массив типа int длиной 4
std::array<int, 4> myarray = { 8, 6, 4, 1 }; // список инициализаторов

std::array поддерживает вторую форму доступа к элементам массива (функция at()), которая осуществляет проверку диапазона:
std::array<int, 4> myarray { 8, 6, 4, 1 };
myarray.at(1) = 7; // элемент массива 1 - корректный, присваиваем элементу массива 1 значение 7
myarray.at(8) = 15; // элемент массива 8 - некорректный, получим ошибку


--------------- Урок 95. Введение в std::vector. Векторы
2) std::vector (или просто вектор) – это тот же динамический массив, но который может сам управлять выделенной себе памятью. Это означает, что вы можете создавать массивы, длина которых задается во время выполнения, без использования операторов new и delete (явного указания выделения и освобождения памяти). std::vector находится в заголовочном файле <vector>.

#include <vector>
 
// нет необходимости указывать длину при инициализации
std::vector<int> array; 
std::vector<int> array2 = { 10, 8, 6, 4, 2, 1 }; // используется список инициализаторов для инициализации массива
std::vector<int> array3 { 10, 8, 6, 4, 2, 1 }; // используется uniform инициализация для инициализации массива (начиная с C++11)


------------------------------------------------------------------------------------------------------------
------------------------------------ Функции в C++ ------------------------------------
------------------------------------------------------------------------------------------------------------

--------------- Урок 96. Параметры и аргументы функций
Параметр функции (или еще формальный параметр) — это переменная, объявленная в объявлении функции:
void boo(int x); // объявление (прототип функции). x - это параметр
 
void boo(int x) // определение (также объявление). x - это параметр
{
}


Аргумент (или еще фактический параметр) — это значение, которое передает в функцию вызывающий объект (caller):
boo(7); // 7 - это аргумент, который передается параметру x
boo(y+1); // значение выражения y+1  - аргумент, который передается параметру x

Когда функция вызывается, все параметры функции создаются как переменные, а значения аргументов копируются в параметры.

--------------- Урок 97. Передача аргументов по значению

--------------- Урок 98. Передача аргументов по ссылке
Иногда случаются ситуации, когда нужно, чтобы функция изменила значение переданного аргумента. Передача по ссылке решает все эти проблемы.
void func(int &x) // x - это переменная-ссылка
{
    x = x + 1;
}
При вызове функции переменная x станет ссылкой на аргумент. 


--------------- Урок 99. Передача аргументов по адресу
Передача аргументов по адресу — это передача адреса переменной-аргумента (не исходной переменной-аргумента). Поскольку аргумент является адресом, то параметром функции должен быть указатель. Затем функция сможет разыменовать этот указатель для доступа или изменения исходного значения.

Ссылки на самом деле реализуются компилятором через указатели. Это означает, что передача по ссылке является просто передачей по адресу.
Передача по адресу на самом деле является передачей адресу по значению! Из этого выходит, что C++ действительно передает всё по значению!


--------------- Урок 100. Возврат значений по ссылке, по адресу и по значению

--------------- Урок 101. Встроенные функции

--------------- Урок 102. Перегрузка функций
Перегрузка функций — это особенность C++, которая позволяет создать несколько функций с одним и тем же именем, но с разными параметрами. 

int subtract(int a, int b); // версия целочисленного типа
double subtract(double a, double b); // версия типа с плавающей запятой
int subtract(int a, int b, int c);

int subtract(int a, int b)
{
    return a - b;
}
double subtract(double a, double b)
{
    return a - b;
}
int subtract(int a, int b, int c)
{
    return a - b - c;
}

Хотя может показаться, что произойдет конфликт имен, но это не так. Компилятор может определить сам, какую версию subtract() следует вызывать на основе аргументов, используемых в вызове функции. Если параметрами будут переменные типа int, то C++ поймет, что мы имеем в виду вызов subtract(int, int). Если мы предоставим два значения типа с плавающей запятой, то C++ поймет, что мы хотим вызвать subtract(double, double). 

Поскольку объявление typedef (псевдонима типа) не создает новый тип, то следующие два объявления print() считаются идентичными:
typedef char *string;
void print(string value);
void print(char *value);


--------------- Урок 103. Параметры по умолчанию
Параметр по умолчанию (также «необязательный параметр» или «аргумент по умолчанию») — это параметр функции, который имеет определенное значение по умолчанию. Если пользователь не передает в функцию значение для параметра по умолчанию, то будет использоваться значение по умолчанию. Если же пользователь передает значение, то это значение будет использоваться вместо значения по умолчанию.

void printValues(int a, int b=5)

1. Все параметры по умолчанию в прототипе или в определении функции должны располагаться справа. 
      void printValue(int a=5, int b);  // не разрешается
      void printValue(int a, int b=5);  // правильно
2. Если имеется более одного параметра по умолчанию, то самым левым параметром по умолчанию должен быть тот, который с наибольшей вероятностью (среди всех остальных параметров) будет явно переопределен пользователем.


--------------- Урок 104. Указатели на функции
// fcnPtr - это указатель на функцию, которая не принимает никаких аргументов и возвращает целочисленное значение
int (*fcnPtr)();


int boo()
{
    return 7;
}
 
int doo()
{
    return 8;
}
 
int main()
{
    int (*fcnPtr)() = boo; // fcnPtr указывает на функцию boo
    fcnPtr = doo; // fcnPtr теперь указывает на функцию doo
 
    return 0;
}


--------------- Урок 105. Стек и Куча
Стек вызовов (или просто «стек») отслеживает все активные функции (те, которые были вызваны, но еще не завершены) от начала программы и до текущей точки выполнения, и обрабатывает выделение всех параметров функции и локальных переменных.
Стек вызовов реализуется как структура данных «Стек». 

Структура данных — это механизм в программировании для организации данных, чтобы они могли эффективно использоваться. Вы уже видели несколько типов структур данных, таких как массивы и структуры. Они обеспечивают механизмы для эффективного хранения данных и доступа к ним. 

В компьютерном программировании стек представляет собой контейнер, как структуру данных, который содержит несколько переменных (подобно массиву). Однако, в то время как массив позволяет получить доступ и изменять элементы в любом порядке (так называемый «произвольный доступ»), то стек более ограничен. В стеке вы можете:
-  Посмотреть на верхний элемент в стеке (используется функция top() или peek()).
-  Вытянуть верхний элемент стека (используется функция pop()).
-  Добавить новый элемент на вершину стека (используется функция push()).

Стек – это структура типа LIFO (Last In, First Out – последним пришёл, первым ушёл). 

При запуске приложения, функция main() помещается в стек вызовов операционной системой. Затем программа начинает своё выполнение.

Пример стека вызовов
int boo(int b)
{
    // b
    return b;
} // boo вытягивается из стека вызовов здесь 
 
int main()
{
    // a
    boo(7); // boo добавляется в стек вызовов здесь
    // c
 
    return 0;
}

Стек вызовов этой программы выглядит следующим образом:
a: 
    main()
b:
    boo() (включая параметр b)
    main()
c:
    main()


Переполнение стека
Стек имеет ограниченный размер и, следовательно, может содержать только ограниченный объем информации. В Windows размер стека по умолчанию составляет 1 МБ. На некоторых других Unix-системах этот размер может достигать и 8 МБ. Если программа пытается поместить слишком много информации в стек, то это приведет к переполнению стека. 
Переполнение стека (stack overflow) происходит при запросе на память, в то время, когда вся память стека уже выделена — в этом случае все запросы на выделения начнут переливаться (переполняться) в другие разделы памяти.

Переполнение стека является результатом добавления слишком большого числа переменных в стек и/или создания слишком большого количества вложенных вызовов функций (например, где функция A вызывает функцию B, которая в свою очередь вызывает функцию C, а та вызывает функцию D и т.д. и т.п.). Переполнение стека обычно приводит к сбою в программе.


--------------- Урок 106. Емкость вектора. std::vector в качестве стека

--------------- Урок 107. Рекурсия. Числа Фибоначчи и Факториал
Рекурсивная функция (рекурсия) в C++ — это функция, которая вызывает саму себя.
Условие завершения рекурсии — это условие, которое, при его выполнении, остановит вызов рекурсивной функции саму себя.

Одним из наиболее известных математических рекурсивных алгоритмов является последовательность Фибоначчи. Последовательности Фибоначчи можно рассмотреть во многих местах природы, таких как ветвление деревьев, спираль раковин, плоды ананаса, разворачивающийся папоротник и т.д.

Математически числа Фибоначчи определяются как:
F(n) = 0 если n = 0
1 если n = 1
f(n-1) + f(n-2) если n > 1


Рекурсивная функция для вычисления n-го числа Фибоначчи:
#include <iostream>
 
int fibonacci(int number)
{
    if (number == 0)
        return 0; // базовый случай (условие завершения)
    if (number == 1)
        return 1; // базовый случай (условие завершения)
    return fibonacci(number-1) + fibonacci(number-2);
}
 
// в main-е выводим первые 13 чисел Фибоначчи
int main()
{
    for (int count=0; count < 13; ++count)
        std:: cout << fibonacci(count) << " ";
 
    return 0;
}

Результат выполнения программы выше: 0 1 1 2 3 5 8 13 21 34 55 89 144

Наиболее популярный вопрос, который задают о рекурсивных функциях — «Зачем использовать рекурсивную функцию, если задание можно выполнить с помощью итераций (используя цикл for или цикл while)?». Оказывается, вы всегда можете решить рекурсивную проблему итеративно — однако для нетривиальных задач рекурсивная версия часто бывает намного проще — как для написания, так и для чтения. Например, функцию вычисления n-го числа Фибоначчи можно написать и методом итераций, но это будет немного сложнее!

Итеративные функции (те, которые используют циклы for или while) почти всегда более эффективны, чем их рекурсивные аналоги. Это связано с тем, что каждый раз, при вызове функции, расходуется определенное количество ресурсов, которое тратится на добавление и вытягивание фреймов из стека. Итеративные функции расходуют намного меньше этих ресурсов.


--------------- Урок 108. Обработка ошибок, cerr и exit

--------------- Урок 109. Assert и static_assert
Функция assert() тратит мало ресурсов на проверку условия. Кроме того, утверждения должны (в идеале) никогда не встречаться в релизном коде (потому что ваш код к этому моменту уже должен быть тщательно протестирован). Следовательно, многие разработчики предпочитают использование assert только в режиме отладки. В C++ есть возможность отключить все assert-ы в релизном коде — использование #define NDEBUG:


--------------- Урок 110. Аргументы командной строки
int main(int argc, char *argv[])
int main(int argc, char** argv)

argc — это целочисленный параметр, содержащий количество аргументов, переданных в программу (argc = argument count – количество аргументов). argc всегда будет как минимум 1, так как первым аргументом всегда является имя самой программы. 

argv — это место, где хранятся фактические значения аргументов (argv = argument values — значения аргументов; хотя изначально было “argument vectors”). Хотя объявление argv выглядит немного пугающе, но это всего лишь массив строк C-style. Длина этого массива — argc.


--------------- Урок 111. Эллипсис. Почему его не следует использовать
Мы должны подключить заголовочный файл cstdarg. Этот заголовок определяет va_list, va_start и va_end — макросы, которые нам нужно использовать для доступа к параметрам, которые являются частью эллипсиса.



Лучшим алгоритмом определения того, существует ли значение в отсортированном массиве или нет, является бинарный поиск.
Бинарный поиск работает следующим образом:
-  смотрим на центральный элемент массива;
-  если центральный элемент массива больше элемента, который мы ищем, то всё, что находится справа от центрального элемента – отбрасываем;
-  если центральный элемент меньше элемента, который мы ищем, то отбрасываем всё, что находится слева от центрального элемента;
-  если центральный элемент равен элементу, который мы ищем, то возвращаем индекс этого элемента;
-  если перебрали весь массив и не нашли искомого значения, то возвращаем контрольное значение с выводом «not found».

------------------------------------------------------------------------------------------------------------
------------------------------------ Основы ООП (Объектно-Ориентированного Программирования) в C++ ------------------------------------
------------------------------------------------------------------------------------------------------------
--------------- Урок №112. Введение в ООП
объект в C++ - «часть памяти, которая используется для хранения значений». Объект с именем называется переменной.
Объекты имеют два основных компонента:
  Список соответствующих свойств (например: вес, цвет, размер, прочность, форма и т.д.).
  Поведение, которое они могут проявлять (например: открывать что-либо, делать что-то и т.д.).

В традиционном программировании, «объект» — это часть памяти для хранения значений. 
В объектно-ориентированном программировании, «объект» — это тот же объект, что и в традиционном программировании, но который соединяет в себе как свойства, так и способы поведения. 

Объектно-ориентированное программирование (ООП) предоставляет возможность создавать объекты, которые соединяют свойства и поведения в самостоятельный союз, который затем можно многоразово использовать. 
ДО ООР:     driveTo(you, work);
ПОСЛЕ ООР:  you.driveTo(work);

Концепции ООР: наследование, инкапсуляция, абстракция и полиморфизм.

--------------- Урок 113. Классы. Объекты и методы классов

Перечисления и структуры — это традиционный (не объектно-ориентированный) мир программирования, поскольку с их использованием мы можем только хранить данные.
Например, структура для хранения даты:
struct DateStruct
{
    int day;
    int month;
    int year;
};

В C++11 мы можем создать и инициализировать структуру следующим образом:
DateStruct today { 12, 11, 2018}; // используем uniform инициализацию

Класс
В мире объектно-ориентированного программирования типы данных могут не только содержать данные, но и функции, которые будут работать с этими данными. Для определения такого типа данных в C++ используется ключевое слово class.

В C++ классы очень похожи на структуры, за исключением того, что они обеспечивают гораздо большую мощность и гибкость. Фактически, следующая структура и класс по выполнению идентичны:

struct DateStruct
{
    int day;
    int month;
    int year;
};
 
class DateClass
{
public:
    int m_day;
    int m_month;
    int m_year;
};

Так же, как объявление структуры, объявление класса не приводит к выделению какой-либо памяти. Для использования класса нужно объявить переменную этого типа класса:
DateClass today { 12, 11, 2018 }; // объявляем переменную класса DateClass

В C++, переменная класса называется экземпляром или объектом класса.
Создание объекта класса (например, DateClass today) приводит к выделению памяти для этого объекта.

Точно так же, как к членам структуры, к членам (переменным и функциям) класса доступ осуществляется через оператор выбора членов (.):

Мы рекомендуем использовать ключевое слово struct для структур, используемых только для хранения данных и ключевое слово class для определения объектов, которые требуют объединения как данных, так и функций.

Стандартная библиотека C++ полна классов, созданных для вашего удобства. std::string, std::vector и std::array – это всё типы классов!

#include <string>
#include <array>
#include <vector>
#include <iostream>
 
int main()
{
    std::string s { "Hello, world!" }; // создаем экземпляр класса string
    std::array<int, 3> a { 7, 8, 9 }; // создаем экземпляр класса array
    std::vector<double> v { 1.5, 2.6, 3.7 }; // создаем экземпляр класса vector
 
    std::cout << "length: " << s.length() << '\n'; // вызываем метод 
 
    return 0;
}


------------------------------------------------------------------------------------------------------------
------------------------------------ Перегрузка операторов в C++ ------------------------------------
------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------
------------------------------------ Введение в отношения между объектами в C++ ------------------------------------
------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------
------------------------------------ Наследование в C++ ------------------------------------
------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------
------------------------------------ Виртуальные функции в C++ ------------------------------------
------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------
------------------------------------ Шаблоны в C++ ------------------------------------
------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------
------------------------------------ Исключения в C++ ------------------------------------
------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------
------------------------------------ Умные указатели и Семантика перемещения в C++ ------------------------------------
------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------
------------------------------------ Стандартная библиотека шаблонов (STL) в С++ ------------------------------------
------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------
------------------------------------ std::string в С++ ------------------------------------
------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------
------------------------------------ Ввод/Вывод (I/O) в С++ ------------------------------------
------------------------------------------------------------------------------------------------------------
